<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<title>Binance Demo Bot</title>
<style>
@import url('https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@400;500;600;700&family=Space+Mono:wght@400;700&display=swap');
:root{
  --bg:#0a0a0f;--surface:#111118;--card:#16161f;--border:#222232;
  --accent:#f0b90b;--green:#00e676;--red:#ff4d6d;--yellow:#ffd166;
  --text:#d0d0e8;--dim:#555570;
  --mono:'Space Mono',monospace;--sans:'Space Grotesk',sans-serif;
}
*{margin:0;padding:0;box-sizing:border-box;-webkit-tap-highlight-color:transparent}
html,body{height:100%;overflow:hidden}
body{background:var(--bg);color:var(--text);font-family:var(--sans);display:flex;flex-direction:column;height:100dvh}

/* â”€â”€ HEADER â”€â”€ */
.hdr{background:var(--surface);border-bottom:1px solid var(--border);padding:12px 16px;display:flex;align-items:center;justify-content:space-between;flex-shrink:0}
.logo{font-size:17px;font-weight:700;display:flex;align-items:center;gap:8px}
.logo-icon{color:var(--accent);font-size:20px}
.logo em{color:var(--accent);font-style:normal}
.hdr-r{display:flex;align-items:center;gap:6px}
.badge{font-family:var(--mono);font-size:9px;font-weight:700;letter-spacing:1px;padding:3px 8px;border-radius:4px}
.b-demo{background:rgba(240,185,11,.15);color:var(--accent);border:1px solid rgba(240,185,11,.35)}
.b-run{background:rgba(0,230,118,.12);color:var(--green);border:1px solid rgba(0,230,118,.3);animation:blink 2s infinite}
.b-off{background:rgba(85,85,112,.15);color:var(--dim);border:1px solid var(--border)}
@keyframes blink{50%{opacity:.5}}

/* â”€â”€ TABS â”€â”€ */
.tabs{display:flex;background:var(--surface);border-bottom:1px solid var(--border);flex-shrink:0}
.tab{flex:1;padding:10px 2px;text-align:center;font-size:10px;font-weight:600;letter-spacing:.6px;text-transform:uppercase;color:var(--dim);cursor:pointer;border-bottom:2px solid transparent;transition:all .2s}
.tab.active{color:var(--accent);border-bottom-color:var(--accent)}

/* â”€â”€ SCROLL â”€â”€ */
.scroll{flex:1;overflow:hidden;position:relative}
.scroll::-webkit-scrollbar{display:none}
.page{display:none;padding:14px 14px 100px 14px}
.page.active{display:block;overflow-y:auto;-webkit-overflow-scrolling:touch;overscroll-behavior:contain;min-height:200px}

/* â”€â”€ BANNERS â”€â”€ */
.banner{display:flex;align-items:center;gap:8px;border-radius:10px;padding:10px 12px;margin-bottom:12px;font-size:12px;border:1px solid;transition:all .4s}
.bn-ok{background:rgba(0,230,118,.07);border-color:rgba(0,230,118,.25);color:var(--green)}
.bn-err{background:rgba(255,77,109,.07);border-color:rgba(255,77,109,.25);color:var(--red)}
.bn-warn{background:rgba(240,185,11,.07);border-color:rgba(240,185,11,.25);color:var(--yellow)}
.bn-info{background:rgba(124,111,255,.07);border-color:rgba(124,111,255,.25);color:#a0a0ff}
.bn-dot{width:7px;height:7px;border-radius:50%;flex-shrink:0;background:currentColor}
.bn-dot.pulse{animation:pulse 2s infinite}
@keyframes pulse{0%,100%{opacity:1}50%{opacity:.3}}

/* â”€â”€ TICKER â”€â”€ */
.ticker-wrap{background:var(--surface);border:1px solid var(--border);border-radius:10px;padding:9px 14px;margin-bottom:12px;overflow:hidden}
.ticker-inner{display:flex;gap:20px;width:max-content}
.ticker-inner.go{animation:scrollT 35s linear infinite}
@keyframes scrollT{from{transform:translateX(0)}to{transform:translateX(-50%)}}
.ti{display:flex;align-items:center;gap:5px;white-space:nowrap}
.ti-s{font-size:11px;font-weight:700}
.ti-p{font-family:var(--mono);font-size:11px}
.ti-c{font-family:var(--mono);font-size:10px}

/* â”€â”€ STAT GRID â”€â”€ */
.sg{display:grid;grid-template-columns:1fr 1fr;gap:8px;margin-bottom:12px}
.sb{background:var(--card);border:1px solid var(--border);border-radius:10px;padding:12px;position:relative;overflow:hidden}
.sb::before{content:'';position:absolute;top:0;left:0;width:3px;height:100%}
.la::before{background:var(--accent)} .lg::before{background:var(--green)}
.lr::before{background:var(--red)}    .ly::before{background:var(--yellow)}
.sl{font-size:9px;letter-spacing:1px;text-transform:uppercase;color:var(--dim);margin-bottom:5px}
.sv{font-family:var(--mono);font-size:18px;font-weight:700}
.sv.g{color:var(--green)} .sv.r{color:var(--red)} .sv.a{color:var(--accent)} .sv.y{color:var(--yellow)}
.ss{font-size:10px;color:var(--dim);margin-top:3px}

/* â”€â”€ CARD â”€â”€ */
.card{background:var(--card);border:1px solid var(--border);border-radius:12px;padding:14px;margin-bottom:10px}
.chdr{display:flex;align-items:center;justify-content:space-between;margin-bottom:12px}
.ct{font-size:10px;font-weight:700;letter-spacing:1.2px;text-transform:uppercase;color:var(--dim)}
.ca{font-size:11px;color:var(--accent);cursor:pointer;font-weight:600}

/* â”€â”€ PROGRESS â”€â”€ */
.pw{margin:8px 0}
.pm{display:flex;justify-content:space-between;font-size:11px;color:var(--dim);margin-bottom:4px}
.pb{height:5px;background:var(--border);border-radius:3px;overflow:hidden}
.pf{height:100%;border-radius:3px;transition:width .6s}

/* â”€â”€ SELECT/DROPDOWN â”€â”€ */
.fs{background:var(--card);color:var(--text);border:1px solid var(--border);border-radius:8px;padding:8px 10px;outline:none;-webkit-appearance:none;appearance:none;cursor:pointer}
.fs option{background:var(--card);color:var(--text)}
/* â”€â”€ CHART â”€â”€ */
canvas.pnl{width:100%;height:80px}

/* â”€â”€ BUTTONS â”€â”€ */
.btn{width:100%;padding:13px;border:none;border-radius:10px;font-family:var(--sans);font-size:14px;font-weight:700;cursor:pointer;transition:all .15s}
.btn:active{transform:scale(.96)}
.btn-y{background:var(--accent);color:#000}
.btn-g{background:var(--green);color:#000}
.btn-r{background:var(--red);color:#fff}
.btn-ghost{background:transparent;border:1px solid var(--border);color:var(--text)}
.b2{display:grid;grid-template-columns:1fr 1fr;gap:8px;margin-top:8px}

/* â”€â”€ TRADE ROW â”€â”€ */
.tr{display:flex;align-items:flex-start;justify-content:space-between;padding:12px 0;border-bottom:1px solid var(--border);gap:8px}
.tr:last-child{border-bottom:none}
.tr-sym{font-size:14px;font-weight:700}
.tr-meta{font-size:10px;color:var(--dim);margin-top:3px}
.chip{display:inline-block;font-size:8px;font-weight:700;letter-spacing:.8px;padding:2px 5px;border-radius:3px;margin-right:3px}
.c-long{background:rgba(0,230,118,.12);color:var(--green)}
.c-short{background:rgba(255,77,109,.12);color:var(--red)}
.c-open{background:rgba(240,185,11,.12);color:var(--accent)}
.c-win{background:rgba(0,230,118,.12);color:var(--green)}
.c-loss{background:rgba(255,77,109,.12);color:var(--red)}
.tr-pnl{font-family:var(--mono);font-size:14px;font-weight:700}

/* â”€â”€ SCAN ROW â”€â”€ */
.srow{display:flex;align-items:center;padding:12px 0;border-bottom:1px solid var(--border);gap:10px;cursor:pointer;width:100%;min-width:0}
.srow:last-child{border-bottom:none}
.srow:active{opacity:.7}
.sico{width:36px;height:36px;border-radius:10px;display:flex;align-items:center;justify-content:center;font-size:15px;flex-shrink:0;font-weight:700}

/* â”€â”€ FORM â”€â”€ */
.fr{margin-bottom:12px}
.fl{font-size:10px;letter-spacing:.8px;text-transform:uppercase;color:var(--dim);margin-bottom:5px;display:block}
.fi{width:100%;background:var(--surface);border:1px solid var(--border);border-radius:8px;padding:11px 12px;color:var(--text);font-family:var(--mono);font-size:13px;outline:none;transition:border-color .2s}
.fi:focus{border-color:var(--accent)}
.fi.pw-field{letter-spacing:2px}
.fs{width:100%;background:var(--surface);border:1px solid var(--border);border-radius:8px;padding:11px 12px;color:var(--text);font-size:13px;outline:none;-webkit-appearance:none}
.f2{display:grid;grid-template-columns:1fr 1fr;gap:8px}
.eye-wrap{position:relative}
.eye-wrap .fi{padding-right:44px}
.eye-btn{position:absolute;right:12px;top:50%;transform:translateY(-50%);background:none;border:none;color:var(--dim);cursor:pointer;font-size:16px;padding:4px}

/* â”€â”€ TOGGLE â”€â”€ */
.trow{display:flex;align-items:center;justify-content:space-between;padding:10px 0;border-bottom:1px solid var(--border)}
.trow:last-child{border-bottom:none}
.tn{font-size:13px;font-weight:500}
.td{font-size:10px;color:var(--dim);margin-top:2px}
.tog{width:42px;height:23px;background:var(--border);border-radius:12px;position:relative;cursor:pointer;transition:background .25s;flex-shrink:0}
.tog.on{background:var(--accent)}
.tog::after{content:'';position:absolute;width:17px;height:17px;border-radius:50%;background:#fff;top:3px;left:3px;transition:left .25s}
.tog.on::after{left:22px}

/* â”€â”€ LOG â”€â”€ */
.logbox{background:var(--surface);border:1px solid var(--border);border-radius:10px;padding:12px;height:240px;overflow-y:auto;font-family:var(--mono);font-size:10px;line-height:1.8}
.logbox::-webkit-scrollbar{display:none}
.ll.info{color:var(--text)} .ll.ok{color:var(--green)} .ll.warn{color:var(--yellow)} .ll.err{color:var(--red)}
.ll .lt{color:var(--dim);margin-right:6px}

/* â”€â”€ MISC â”€â”€ */
.empty{text-align:center;color:var(--dim);font-size:12px;padding:24px 0}
.ei{font-size:28px;margin-bottom:6px}
.sec-lbl{font-size:10px;letter-spacing:1px;text-transform:uppercase;color:var(--dim);margin:14px 0 8px}
.divider{height:1px;background:var(--border);margin:14px 0}
.warn-box{background:rgba(255,77,109,.07);border:1px solid rgba(255,77,109,.25);border-radius:10px;padding:12px;font-size:12px;color:var(--red);line-height:1.6;margin-bottom:12px}
.info-box{background:rgba(240,185,11,.07);border:1px solid rgba(240,185,11,.25);border-radius:10px;padding:12px;font-size:12px;color:var(--yellow);line-height:1.7;margin-bottom:12px}

.toast{position:fixed;bottom:80px;left:50%;transform:translateX(-50%);background:var(--card);border:1px solid var(--border);border-radius:20px;padding:10px 18px;font-size:13px;font-weight:600;z-index:999;white-space:nowrap;box-shadow:0 8px 32px rgba(0,0,0,.5);animation:tin .2s ease}
@keyframes tin{from{transform:translateX(-50%) translateY(20px);opacity:0}}

.sheet-ov{display:none;position:fixed;inset:0;background:rgba(0,0,0,.85);z-index:500;align-items:flex-end}
.sheet-ov.show{display:flex}
.sheet{background:var(--card);border:1px solid var(--border);border-radius:20px 20px 0 0;padding:20px 16px 40px;width:100%;animation:sup .2s ease;max-height:90vh;overflow-y:auto}
@keyframes sup{from{transform:translateY(100%)}}
.sh-ttl{font-size:16px;font-weight:700;margin-bottom:16px;display:flex;justify-content:space-between;align-items:center}
.sh-x{color:var(--dim);cursor:pointer;font-size:22px;line-height:1}

/* â”€â”€ BALANCE BOX â”€â”€ */
.bal-grid{display:grid;grid-template-columns:repeat(3,1fr);gap:6px;margin-bottom:12px}
.bal-box{background:var(--card);border:1px solid var(--border);border-radius:8px;padding:10px;text-align:center}
.bal-lbl{font-size:9px;letter-spacing:.8px;text-transform:uppercase;color:var(--dim);margin-bottom:4px}
.bal-val{font-family:var(--mono);font-size:13px;font-weight:700;color:var(--accent)}

/* â”€â”€ SETUP STEPS â”€â”€ */
.step{display:flex;gap:12px;margin-bottom:14px;align-items:flex-start}
.step-num{width:26px;height:26px;border-radius:50%;background:rgba(240,185,11,.15);border:1px solid rgba(240,185,11,.35);color:var(--accent);font-size:12px;font-weight:700;display:flex;align-items:center;justify-content:center;flex-shrink:0;margin-top:1px}
.step-text{font-size:12px;line-height:1.6;color:var(--text)}
.step-text strong{color:var(--accent)}
</style>
</head>
<body>

<div class="hdr">
  <div class="logo"><span class="logo-icon">â—ˆ</span>Demo<em>Bot</em></div>
  <div class="hdr-r">
    <div class="badge b-demo">DEMO</div>
    <div class="badge b-off" id="botBadge">STOPPED</div>
  </div>
</div>

<div class="tabs">
  <div class="tab active" onclick="nav('dash')">ğŸ“Š Dash</div>
  <div class="tab" onclick="nav('scanner')">ğŸ” Scan</div>
  <div class="tab" onclick="nav('trades')">ğŸ“‹ Trades</div>
  <div class="tab" onclick="nav('config')">âš™ï¸ Config</div>
  <div class="tab" onclick="nav('setup')">ğŸ”‘ Keys</div>
</div>

<div class="scroll">

<!-- â•â•â•â•â•â•â•â• DASHBOARD â•â•â•â•â•â•â•â• -->
<div class="page active" id="pg-dash">

  <div class="banner bn-warn" id="connBanner">
    <div class="bn-dot" id="connDot"></div>
    <span id="connText">Enter API keys in the Keys tab to connect</span>
  </div>

  <!-- Ticker -->
  <div class="ticker-wrap">
    <div class="ticker-inner" id="tickerInner">
      <span style="color:var(--dim);font-size:11px;font-family:var(--mono)">Waiting for live pricesâ€¦</span>
    </div>
  </div>

  <!-- Demo Account Balance (from API) -->
  <div class="bal-grid">
    <div class="bal-box"><div class="bal-lbl">Demo Balance</div><div class="bal-val" id="acctBal">â€”</div></div>
    <div class="bal-box"><div class="bal-lbl">Unrealised PnL</div><div class="bal-val" id="acctUpnl" style="color:var(--green)">â€”</div></div>
    <div class="bal-box"><div class="bal-lbl">Margin Used</div><div class="bal-val" id="acctMargin">â€”</div></div>
  </div>

  <!-- Stats -->
  <div class="sg">
    <div class="sb la"><div class="sl">Session Capital</div><div class="sv a" id="s-cap">$2000.00</div><div class="ss" id="cap-started">Started: $1000</div></div>
    <div class="sb lg"><div class="sl">Session P&L</div><div class="sv g" id="s-pnl">+$0.00</div><div class="ss" id="s-pct">0.00%</div></div>
    <div class="sb ly"><div class="sl">Trades</div><div class="sv y" id="s-trades">0/30</div><div class="ss">demo orders</div></div>
    <div class="sb lg"><div class="sl">Win Rate</div><div class="sv g" id="s-wr">â€”</div><div class="ss" id="s-wl">0W / 0L</div></div>
  </div>

  <!-- Open PnL + Closed PnL -->
  <div class="sg" style="margin-top:0">
    <div class="sb" style="border-left:3px solid var(--accent)">
      <div class="sl">ğŸ“‚ Open PnL</div>
      <div class="sv" id="open-pnl" style="color:var(--dim)">â€”</div>
      <div class="ss" id="open-pnl-sub">0 positions</div>
    </div>
    <div class="sb" style="border-left:3px solid var(--green)">
      <div class="sl">âœ… Closed PnL</div>
      <div class="sv" id="closed-pnl" style="color:var(--dim)">â€”</div>
      <div class="ss" id="closed-pnl-sub">0 trades</div>
    </div>
    <div class="sb" style="border-left:3px solid #7c6fff">
      <div class="sl">ğŸ’° Total PnL</div>
      <div class="sv" id="total-pnl-card" style="color:var(--dim)">â€”</div>
      <div class="ss" id="total-pnl-sub">open + closed</div>
    </div>
  </div>

  <!-- P&L Chart -->
  <div class="card">
    <div class="chdr"><div class="ct">P&L Curve</div><div class="ca" onclick="resetSession()">Reset</div></div>
    <canvas class="pnl" id="pnlChart"></canvas>
  </div>

  <!-- Progress -->
  <div class="card">
    <div class="ct" style="margin-bottom:10px">Daily Goals</div>
    <div class="pw"><div class="pm"><span>Profit Target ($200)</span><span id="p1t">$0</span></div><div class="pb"><div class="pf" id="p1" style="width:0%;background:var(--green)"></div></div></div>
    <div class="pw"><div class="pm"><span>Trades (20)</span><span id="p2t">0/20</span></div><div class="pb"><div class="pf" id="p2" style="width:0%;background:var(--accent)"></div></div></div>
    <div class="pw"><div class="pm"><span>Loss Guard ($200 max)</span><span id="p3t">$0</span></div><div class="pb"><div class="pf" id="p3" style="width:0%;background:var(--red)"></div></div></div>
  </div>

  <!-- Open Positions -->
  <div class="card">
    <div class="chdr"><div class="ct">Open Positions</div><div style="display:flex;gap:10px;align-items:center"><span class="ca" style="color:var(--red);font-size:11px" onclick="closeAllPositions()">âœ• Close All</span><span class="ca" id="posCount">0 open</span></div></div>
    <div id="openPos"><div class="empty"><div class="ei">ğŸ“­</div>No open positions</div></div>
  </div>

  <button class="btn btn-y" id="mainBtn" onclick="toggleBot()">â–¶ START DEMO BOT</button>

  <!-- BOT LOG -->
  <div style="margin-top:16px;padding-bottom:20px">
    <div style="font-size:10px;letter-spacing:1px;text-transform:uppercase;color:var(--dim);margin-bottom:8px">ğŸ“‹ Bot Activity Log</div>
    <div id="logBox" style="background:var(--surface);border:1px solid var(--border);border-radius:10px;padding:10px 12px;height:220px;overflow-y:auto;font-family:var(--mono);font-size:10px;line-height:1.9;-webkit-overflow-scrolling:touch;"></div>
    <div style="display:grid;grid-template-columns:1fr 1fr 1fr;gap:6px;margin-top:8px">
      <button class="btn btn-ghost" style="font-size:12px;padding:10px" onclick="document.getElementById('logBox').innerHTML=''">ğŸ—‘ Clear</button>
      <button class="btn btn-ghost" style="font-size:12px;padding:10px" onclick="copyLog()">ğŸ“‹ Copy Log</button>
      <button class="btn btn-ghost" style="font-size:12px;padding:10px" onclick="forceScan()">â–¶ Force Scan</button>
    </div>
  </div>
</div>

<!-- â•â•â•â•â•â•â•â• SCANNER â•â•â•â•â•â•â•â• -->
<div class="page" id="pg-scanner">

  <!-- SEARCH & ANALYZE -->
  <div class="card">
    <div class="chdr"><div class="ct">ğŸ” Search & Analyze</div></div>
    <div style="display:flex;gap:8px;margin-bottom:10px">
      <input class="fi" id="searchInput" placeholder="Type coin: BTC, ETH, PEPEâ€¦" style="flex:1;text-transform:uppercase" oninput="this.value=this.value.toUpperCase()">
      <button class="btn btn-y" style="width:auto;padding:0 16px;font-size:13px;white-space:nowrap" onclick="searchAndAnalyze()">Analyze</button>
    </div>
    <div id="searchResult" style="display:none">
      <!-- filled by searchAndAnalyze() -->
    </div>
  </div>

  <!-- QUICK FILTERS -->
  <div class="card">
    <div class="chdr"><div class="ct">ğŸ“Š Market Scanner</div><div class="ca" onclick="runScan()">â†» Refresh</div></div>
    <div style="display:grid;grid-template-columns:1fr 1fr 1fr;gap:6px;margin-bottom:10px">
      <button id="sf-all" class="btn btn-ghost" style="font-size:11px;padding:8px;border:1px solid var(--accent);color:var(--accent)" onclick="setScanMode('all')">ğŸ“‹ All</button>
      <button id="sf-gainers" class="btn btn-ghost" style="font-size:11px;padding:8px" onclick="setScanMode('gainers')">ğŸ”¥ Gainers</button>
      <button id="sf-losers" class="btn btn-ghost" style="font-size:11px;padding:8px" onclick="setScanMode('losers')">ğŸ“‰ Losers</button>
      <button id="sf-signals" class="btn btn-ghost" style="font-size:11px;padding:8px" onclick="setScanMode('signals')">âš¡ Signals</button>
    </div>
    <div class="fr" style="margin-bottom:8px">
      <input class="fi" id="symSearch" placeholder="Filter list (BTC, SOLâ€¦)" oninput="runScan()" style="font-size:12px">
    </div>
    <div id="scanList" style="display:flex;flex-direction:column;gap:0;clear:both"><div class="empty"><div class="ei">ğŸ”</div>Loading symbolsâ€¦ connect API keys to scan</div></div>
  </div>

</div>

<!-- â•â•â•â•â•â•â•â• TRADES â•â•â•â•â•â•â•â• -->
<div class="page" id="pg-trades">

  <!-- Summary row -->
  <div class="sg">
    <div class="sb la"><div class="sl">Total</div><div class="sv a" id="t-total">0</div><div class="ss">trades</div></div>
    <div class="sb lg"><div class="sl">Realised P&L</div><div class="sv g" id="t-pnl">$0.00</div></div>
    <div class="sb lg"><div class="sl">Best</div><div class="sv g" id="t-best">â€”</div></div>
    <div class="sb lr"><div class="sl">Worst</div><div class="sv r" id="t-worst">â€”</div></div>
  </div>

  <!-- Filter bar -->
  <div class="card" style="padding:10px 14px">
    <div style="display:flex;gap:8px;margin-bottom:10px">
      <select id="tf-status" class="fs" style="flex:1;font-size:12px" onchange="setTradeFilter(this.value)">
        <option value="all">ğŸ“‹ All Trades</option>
        <option value="open">âš¡ Open Only</option>
        <option value="closed">âœ… Closed Only</option>
        <option value="win">ğŸ’° Wins Only</option>
        <option value="loss">ğŸ”´ Losses Only</option>
        <option value="sl">â›” Stop Loss Hits</option>
        <option value="tp">ğŸ¯ TP Targets Hit</option>
        <option value="manual">âœ• Manual Closes</option>
      </select>
      <select id="tf-time" class="fs" style="flex:1;font-size:12px" onchange="renderTrades()">
        <option value="all">ğŸ“… All Time</option>
        <option value="today">Today</option>
        <option value="yesterday">Yesterday</option>
        <option value="7d">Last 7 Days</option>
        <option value="30d">Last 30 Days</option>
      </select>
    </div>
    <div style="display:flex;gap:8px">
      <button class="btn btn-ghost" style="font-size:11px;padding:7px 12px;flex:1" onclick="refreshTradesFromBinance()">ğŸ”„ Sync</button>
      <button class="btn btn-ghost" style="font-size:11px;padding:7px 12px;flex:1;color:var(--red)" onclick="clearHistory()">ğŸ—‘ Clear Closed</button>
      <button class="btn btn-ghost" style="font-size:11px;padding:7px 12px;flex:1;color:#ff0044;border-color:#ff0044;font-weight:700" onclick="resetEverything()">âš ï¸ Full Reset</button>
    </div>
  </div>

  <!-- Trade journal list -->
  <div id="tradeList" style="padding-bottom:80px"><div class="empty"><div class="ei">ğŸ“‹</div>No trades yet</div></div>

</div>

<!-- â•â•â•â•â•â•â•â• CONFIG â•â•â•â•â•â•â•â• -->
<div class="page" id="pg-config">
  <div class="card">
    <div class="ct" style="margin-bottom:12px">Strategy</div>
    <div class="fr"><label class="fl">Strategy</label>
      <select class="fs" id="cfgStrat">
        <option value="rsi">RSI Reversal (RSI &lt;30 / &gt;70)</option>
        <option value="ema">EMA Crossover (9/21)</option>
        <option value="vol">Volume Spike</option>
        <option value="break">Breakout (20-bar H/L)</option>
        <option value="macd">MACD Signal</option>
        <option value="mixed">Mixed (rotates all)</option>
      </select>
    </div>
    <div class="f2">
      <div class="fr"><label class="fl">Trade Size ($)</label><input class="fi" id="cfgSize" type="number" value="100"></div>
      <div class="fr"><label class="fl">Leverage</label><input class="fi" id="cfgLev" type="number" value="10" min="1" max="20"></div>
    </div>
    <div class="f2">
      <div class="fr"><label class="fl">Take Profit ($)</label><input class="fi" id="cfgTP" type="number" value="25"></div>
      <div class="fr"><label class="fl">Stop Loss ($)</label><input class="fi" id="cfgSL" type="number" value="18"></div>
    </div>
    <div class="f2">
      <div class="fr"><label class="fl">Max Trades/Day</label><input class="fi" id="cfgMaxT" type="number" value="30"></div>
      <div class="fr"><label class="fl">Max Open</label><input class="fi" id="cfgMaxP" type="number" value="5"></div>
    </div>
  </div>
  <div class="card">
    <div class="ct" style="margin-bottom:10px">Risk Controls</div>
    <div class="trow"><div><div class="tn">Daily Loss Guard</div><div class="td">Stop if daily loss > $200</div></div><div class="tog on" id="tog-dlg" onclick="togSet('dlg')"></div></div>
    <div class="trow"><div><div class="tn">Auto TP/SL Orders</div><div class="td">Place TP & SL on Binance Demo</div></div><div class="tog on" id="tog-tpsl" onclick="togSet('tpsl')"></div></div>
    <div class="trow"><div><div class="tn">Auto-Trade Signals</div><div class="td">Bot places demo orders automatically</div></div><div class="tog on" id="tog-auto" onclick="togSet('auto')"></div></div>
    <div class="trow"><div><div class="tn">Realistic Slippage</div><div class="td">Simulate 0.05% slippage</div></div><div class="tog on" id="tog-slip" onclick="togSet('slip')"></div></div>
  </div>
  <button class="btn btn-y" onclick="saveConfig()">Save Configuration</button>
</div>

<!-- â•â•â•â•â•â•â•â• SETUP / KEYS â•â•â•â•â•â•â•â• -->
<div class="page" id="pg-setup">

  <div class="info-box">
    âš ï¸ Keys are stored <strong>only in your browser</strong> on this device. They are never sent anywhere except directly to demo-fapi.binance.com.
  </div>

  <div class="card">
    <div class="ct" style="margin-bottom:14px">ğŸ”‘ Binance Demo API Keys</div>

    <div class="fr">
      <label class="fl">API Key</label>
      <div class="eye-wrap">
        <input class="fi pw-field" id="apiKey" type="password" placeholder="Paste your Demo API Key" autocomplete="off">
        <button class="eye-btn" onclick="toggleEye('apiKey',this)">ğŸ‘</button>
      </div>
    </div>
    <div class="fr">
      <label class="fl">Secret Key</label>
      <div class="eye-wrap">
        <input class="fi pw-field" id="apiSecret" type="password" placeholder="Paste your Demo Secret Key" autocomplete="off">
        <button class="eye-btn" onclick="toggleEye('apiSecret',this)">ğŸ‘</button>
      </div>
    </div>

    <button class="btn btn-y" onclick="connectAPI()" id="connectBtn">Connect to Binance Demo</button>

    <div id="connectResult" style="margin-top:12px;font-size:12px;text-align:center;color:var(--dim)"></div>
  </div>

  <div class="card">
    <div class="ct" style="margin-bottom:12px">ğŸ“‹ How to get your Demo API Keys</div>
    <div class="step"><div class="step-num">1</div><div class="step-text">Go to <strong>demo.binance.com</strong> on your phone</div></div>
    <div class="step"><div class="step-num">2</div><div class="step-text">Tap the menu â†’ <strong>API Management</strong></div></div>
    <div class="step"><div class="step-num">3</div><div class="step-text">Tap <strong>Create API</strong> â†’ System Generated â†’ name it <strong>demobot</strong></div></div>
    <div class="step"><div class="step-num">4</div><div class="step-text">Enable <strong>Futures Trading</strong> permission only</div></div>
    <div class="step"><div class="step-num">5</div><div class="step-text">Copy <strong>API Key</strong> and <strong>Secret Key</strong> â€” paste them above</div></div>

    <div class="divider"></div>
    <div class="warn-box">ğŸ”’ Never share your real Binance API keys with anyone. Demo keys only work on demo.binance.com â€” safe to use here.</div>
  </div>

  <div class="card">
    <div class="ct" style="margin-bottom:10px">Connection Status</div>
    <div id="apiStatus" style="font-family:var(--mono);font-size:11px;line-height:2;color:var(--dim)">Not connected yet.</div>
  </div>
</div>

</div><!-- /scroll -->

<!-- Sheet -->
<div class="sheet-ov" id="sheet">
  <div class="sheet">
    <div class="sh-ttl"><span id="sh-title">â€”</span><span class="sh-x" onclick="closeSheet()">Ã—</span></div>
    <div id="sh-body"></div>
  </div>
</div>

<input type="hidden" id="manSym" value="">
<input type="hidden" id="manSize" value="100">
<input type="hidden" id="manLev" value="0">
<script>
// â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
// â•‘  BINANCE DEMO TRADING BOT                                   â•‘
// â•‘  API: https://demo-fapi.binance.com  (official demo)        â•‘
// â•‘  Prices: wss://stream.binance.com (public WebSocket)        â•‘
// â•‘  Orders: REAL demo orders on your Binance Demo account      â•‘
// â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

const DEMO_API  = 'https://demo-fapi.binance.com';
const WS_STREAM = 'wss://stream.binance.com:9443/stream';

// Base symbols â€” expanded to 30 coins
let SYMBOLS = [
  // Tier 1 â€” always liquid, always fetchable
  'BTCUSDT','ETHUSDT','BNBUSDT','SOLUSDT','XRPUSDT','DOGEUSDT','ADAUSDT',
  // Tier 2 â€” large cap, high volume futures
  'AVAXUSDT','LINKUSDT','DOTUSDT','LTCUSDT','TRXUSDT','NEARUSDT','ATOMUSDT',
  'UNIUSDT','AAVEUSDT','FILUSDT','ICPUSDT','VETUSDT','ALGOUSDT',
  // Tier 3 â€” mid cap but reliable futures
  'SUIUSDT','APTUSDT','INJUSDT','SEIUSDT','TIAUSDT','OPUSDT','ARBUSDT',
  'WLDUSDT','STXUSDT','RUNEUSDT','KAVAUSDT','ZILUSDT','IOTAUSDT',
  'BANDUSDT','CRVUSDT','GRTUSDT','SNXUSDT','1INCHUSDT','SANDUSDT',
  'MANAUSDT','GALAUSDT','ENJUSDT','CHZUSDT','FLOWUSDT','EGLDUSDT',
  // Extra volume coins confirmed on futures
  'ZECUSDT','DASHUSDT','XMRUSDT','COMPUSDT','YFIUSDT','SUSHIUSDT',
  '1000SHIBUSDT','1000PEPEUSDT','WIFUSDT','BONKUSDT','FLOKIUSDT'
];
const ICONS = {
  BTCUSDT:'â‚¿', ETHUSDT:'Î',  BNBUSDT:'B',  SOLUSDT:'â—',  XRPUSDT:'âœ•',
  DOGEUSDT:'Ã',ADAUSDT:'â‚³',  AVAXUSDT:'A', LINKUSDT:'â¬¡', DOTUSDT:'â—',
  LTCUSDT:'Å', TRXUSDT:'T',  NEARUSDT:'N', ATOMUSDT:'âš›', UNIUSDT:'ğŸ¦„',
  AAVEUSDT:'A',FILUSDT:'F',  ICPUSDT:'I',  VETUSDT:'V',  ALGOUSDT:'A',
  SUIUSDT:'S', APTUSDT:'A',  INJUSDT:'I',  SEIUSDT:'S',  TIAUSDT:'T',
  OPUSDT:'O',  ARBUSDT:'A',  WLDUSDT:'W',  STXUSDT:'S',  RUNEUSDT:'R',
  KAVAUSDT:'K',ZILUSDT:'Z',  IOTAUSDT:'I', BANDUSDT:'B', CRVUSDT:'C',
  GRTUSDT:'G', SNXUSDT:'S',  SANDUSDT:'S', MANAUSDT:'M', GALAUSDT:'G',
  ENJUSDT:'E', CHZUSDT:'C',  FLOWUSDT:'F', EGLDUSDT:'E', ZECUSDT:'Z',
  DASHUSDT:'D',XMRUSDT:'X',  COMPUSDT:'C', YFIUSDT:'Y',  SUSHIUSDT:'S',
  '1INCHUSDT':'1','1000SHIBUSDT':'ğŸ•','1000PEPEUSDT':'ğŸ¸',
  WIFUSDT:'ğŸ¶',BONKUSDT:'ğŸ•', FLOKIUSDT:'F',
};

// Proven tradeable symbols cache â€” validated by successful candle fetch
const provenSymbols = new Set([
  'BTCUSDT','ETHUSDT','BNBUSDT','SOLUSDT','XRPUSDT','DOGEUSDT','ADAUSDT',
  'AVAXUSDT','LINKUSDT','DOTUSDT','LTCUSDT','TRXUSDT','NEARUSDT','ATOMUSDT'
]);

async function canFetchCandles(sym) {
  // Quick probe â€” just 5 candles to check if symbol is tradeable on futures
  try {
    const r = await fetch(
      'https://fapi.binance.com/fapi/v1/klines?symbol='+sym+'&interval=5m&limit=5',
      { signal: AbortSignal.timeout(4000) }
    );
    const d = await r.json();
    if (Array.isArray(d) && d.length >= 3) { provenSymbols.add(sym); return true; }
  } catch(e) {}
  // Try spot as fallback
  try {
    const r = await fetch(
      'https://api.binance.com/api/v3/klines?symbol='+sym+'&interval=5m&limit=5',
      { signal: AbortSignal.timeout(4000) }
    );
    const d = await r.json();
    if (Array.isArray(d) && d.length >= 3) { provenSymbols.add(sym); return true; }
  } catch(e) {}
  return false;
}

async function loadTopGainers() {
  try {
    const r = await fetch('https://fapi.binance.com/fapi/v1/ticker/24hr');
    const all = await r.json();

    const STABLES = new Set(['USDCUSDT','USD1USDT','EURUSDT','PAXGUSDT','STABLEUSDT',
      'TUSDUSDT','BUSDUSDT','FDUSDUSDT','USDTUSDT','DAIUSDT','FRAXUSDT',
      'USDDUSDT','GUSDUSDT','LUSDUSDT','XAUUSDT','BTCDOMUSDT','USDTBINANANCE']);

    // Get top 40 by volume and price change
    const candidates = all
      .filter(t => {
        if (!t.symbol.endsWith('USDT')) return false;
        if (t.symbol.includes('_')) return false;
        if (STABLES.has(t.symbol)) return false;
        if (SKIP_SYMBOLS.has(t.symbol)) return false;
        if (parseFloat(t.quoteVolume) < 100000000) return false; // min $100M volume
        if (Math.abs(parseFloat(t.priceChangePercent)) < 0.3) return false;
        return true;
      })
      .sort((a,b) => parseFloat(b.priceChangePercent) - parseFloat(a.priceChangePercent))
      .slice(0, 40);

    all.forEach(t => {
      if (st.prices[t.symbol] === undefined) st.prices[t.symbol] = parseFloat(t.lastPrice);
    });

    // Separate: already proven vs needs validation
    const proven  = candidates.filter(t => provenSymbols.has(t.symbol)).map(t => t.symbol);
    const unknown = candidates.filter(t => !provenSymbols.has(t.symbol)).map(t => t.symbol);

    // Add proven ones immediately
    const top = proven.slice(0, 20);
    gainersCache = top;
    if (top.length) {
      SYMBOLS = [...new Set([...top, ...SYMBOLS])].slice(0, 60);
      log('ğŸ”¥ Gainers (proven): '+top.slice(0,5).join(', ')+(top.length>5?'â€¦':''), 'ok');
    }

    // Validate unknown ones in background â€” don't block scan
    if (unknown.length > 0) {
      log('ğŸ” Validating '+unknown.length+' new gainer symbolsâ€¦', 'info');
      (async () => {
        let added = 0;
        for (const sym of unknown) {
          if (added >= 10) break; // max 10 new per refresh
          if (await canFetchCandles(sym)) {
            if (!SYMBOLS.includes(sym)) {
              SYMBOLS = [...new Set([sym, ...SYMBOLS])].slice(0, 60);
              gainersCache = [...new Set([sym, ...gainersCache])];
              added++;
              log('âœ… Validated gainer: '+sym, 'ok');
            }
          }
          await new Promise(r => setTimeout(r, 300)); // rate limit
        }
        if (added > 0) {
          runScan(); // refresh scan with newly validated symbols
          log('ğŸ”¥ '+added+' new gainer symbols validated and added', 'ok');
        }
      })();
    }

  } catch(e) {
    log('Gainers fetch failed: '+e.message, 'warn');
  }
}

// â”€â”€ STATE â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const st = {
  running: false,
  connected: false,
  apiKey: '', apiSecret: '',

  // Market data (from public WebSocket â€” no CORS)
  prices: {}, change24h: {}, candles: {}, wsReady: {},
  wsTicks: 0,

  // Session tracking
  capital: 2000, todayPnl: 0, totalPnl: 0, todayLoss: 0,
  tradeCount: 0, wins: 0, losses: 0,
  openPos: [], allTrades: [], pnlHistory: [0],

  ws: null, wsKlines: {},
  loopInterval: null, monitorInterval: null, balanceInterval: null, syncInterval: null,
  tickStep: 0,

  cfg: { strategy:'mixed', size:50, leverage:20, tp:25, sl:15, maxTrades:300, maxOpen:20, startCapital:1000 },
  togs: { dlg:true, tpsl:true, auto:true, slip:true }
};

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// HMAC-SHA256 SIGNING (Web Crypto API â€” works in mobile browsers)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
async function sign(secret, message) {
  const enc = new TextEncoder();
  const key = await crypto.subtle.importKey(
    'raw', enc.encode(secret),
    { name:'HMAC', hash:'SHA-256' }, false, ['sign']
  );
  const sig = await crypto.subtle.sign('HMAC', key, enc.encode(message));
  return Array.from(new Uint8Array(sig)).map(b=>b.toString(16).padStart(2,'0')).join('');
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// BINANCE DEMO API CALLS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
async function demoGET(path, params={}) {
  try {
    params.timestamp = Date.now();
    params.recvWindow = 10000; // wider window to fix timestamp errors
    const qs  = new URLSearchParams(params).toString();
    const sig = await sign(st.apiSecret, qs);
    const fullUrl = DEMO_API+path+'?'+qs+'&signature='+sig;
    // Try direct first
    try {
      const res = await fetch(fullUrl, {headers:{'X-MBX-APIKEY':st.apiKey},signal:AbortSignal.timeout(6000)});
      const data = await res.json();
      if (data.code && data.code < 0) throw new Error(data.msg);
      return data;
    } catch(e2) {}
    // Fallback to proxy
    if (!activeProxy) await findProxy();
    if (!activeProxy) return null;
    // Re-sign with fresh timestamp for proxy
    params.timestamp = Date.now();
    const qs2 = new URLSearchParams(params).toString();
    const sig2 = await sign(st.apiSecret, qs2);
    const proxyUrl = activeProxy + encodeURIComponent(DEMO_API+path+'?'+qs2+'&signature='+sig2);
    const res2 = await fetch(proxyUrl, {headers:{'X-MBX-APIKEY':st.apiKey},signal:AbortSignal.timeout(8000)});
    const data2 = await res2.json();
    if (data2.code && data2.code < 0) throw new Error(data2.msg);
    return data2;
  } catch(e) {
    log('GET '+path+': '+e.message,'err');
    return null;
  }
}

// CORS proxies â€” tried in order until one works
const PROXIES = [
  'https://corsproxy.io/?',
  'https://api.allorigins.win/raw?url=',
  'https://corsproxy.org/?url=',
  'https://proxy.cors.sh/',
  'https://thingproxy.freeboard.io/fetch/',
];
let activeProxy = null;
let proxyFailCount = 0;

async function findProxy(force=false) {
  if (activeProxy && !force) return activeProxy;
  for (const p of PROXIES) {
    try {
      const url = p + encodeURIComponent('https://demo-fapi.binance.com/fapi/v1/time');
      const r = await fetch(url, {signal:AbortSignal.timeout(4000)});
      if (r.ok || r.status===400) { 
        activeProxy=p; proxyFailCount=0;
        log('âœ… Proxy: '+p.split('/')[2],'ok'); 
        localStorage.setItem('demoProxy', p);
        return p; 
      }
    } catch(e){}
  }
  log('âš ï¸ All proxies failed','warn');
  return null;
}

async function demoPOST(path, params={}) {
  try {
    params.timestamp = Date.now();
    params.recvWindow = 10000;
    const qs  = new URLSearchParams(params).toString();
    const sig = await sign(st.apiSecret, qs);
    const body = qs + '&signature=' + sig;

    // Try direct POST first (works if CORS headers set by server)
    try {
      const res = await fetch(`${DEMO_API}${path}`, {
        method: 'POST',
        headers: {'X-MBX-APIKEY': st.apiKey, 'Content-Type': 'application/x-www-form-urlencoded'},
        body,
        signal: AbortSignal.timeout(8000)
      });
      const data = await res.json();
      if (data.code && data.code < 0) throw new Error(data.msg);
      log('âœ… Direct POST success: '+path,'ok');
      return data;
    } catch(e) {
      log('Direct POST blocked (CORS) â€” trying proxyâ€¦','warn');
    }

    // Fallback: proxy POST â€” rotate if current proxy failing
    proxyFailCount++;
    if (proxyFailCount > 3) { activeProxy = null; proxyFailCount = 0; }
    if (!activeProxy) await findProxy(true);
    if (!activeProxy) { log('No working proxy for POST','err'); return null; }

    const proxyUrl = activeProxy + encodeURIComponent(`${DEMO_API}${path}`);
    const res2 = await fetch(proxyUrl, {
      method: 'POST',
      headers: {'X-MBX-APIKEY': st.apiKey, 'Content-Type': 'application/x-www-form-urlencoded'},
      body,
      signal: AbortSignal.timeout(8000)
    });
    const data2 = await res2.json();
    if (data2.code && data2.code < 0) throw new Error(data2.msg);
    log('âœ… Proxy POST success: '+path,'ok');
    return data2;

  } catch(e) {
    // Silence expected non-critical errors
    if (!e.message.includes('No need to change margin type')) {
      log('POST error '+path+': '+e.message, e.message.includes('Invalid')?'err':'warn');
    }
    return null;
  }
}

// â”€â”€ TEST CONNECTION â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
async function connectAPI() {
  const key    = document.getElementById('apiKey').value.trim();
  const secret = document.getElementById('apiSecret').value.trim();

  if (!key || !secret) { toast('Enter both API Key and Secret Key'); return; }
  if (key.length < 20 || secret.length < 20) { toast('Keys look too short â€” check them'); return; }

  st.apiKey    = key;
  st.apiSecret = secret;

  document.getElementById('connectBtn').textContent = 'Connectingâ€¦';
  document.getElementById('connectResult').textContent = 'Testing connection to demo-fapi.binance.comâ€¦';

  // Find working CORS proxy for POST orders
  findProxy();

  // Test with account balance endpoint
  const bal = await fetchBalance();
  if (bal) {
    st.connected = true;
    setBanner('ok', 'ğŸŸ¢ Connected to Binance Demo Trading');
    document.getElementById('connectBtn').textContent = 'âœ“ Connected';
    document.getElementById('connectBtn').className   = 'btn btn-ghost';
    document.getElementById('connectResult').style.color = 'var(--green)';
    document.getElementById('connectResult').textContent = 'âœ… Successfully connected to demo-fapi.binance.com';
    log('âœ… Connected to Binance Demo API (demo-fapi.binance.com)', 'ok');

    // Save to localStorage (persists across reloads â€” fixes auto-logout)
    localStorage.setItem('demoKey',    key);
    localStorage.setItem('demoSecret', secret);
    localStorage.setItem('demoProxy', activeProxy||'');

    updateAPIStatus();
    startPriceStream();
    startBalancePolling();
    // Immediately sync real positions from Binance after connecting
    setTimeout(()=>syncPositionsFromBinance(), 3000);
    toast('Connected to Binance Demo! âœ“');
  } else {
    st.connected = false;
    document.getElementById('connectBtn').textContent = 'Retry Connection';
    document.getElementById('connectResult').style.color = 'var(--red)';
    document.getElementById('connectResult').textContent = 'âŒ Connection failed â€” check your keys';
    log('âŒ Connection failed. Check API key and secret.', 'err');
    setBanner('err', 'âŒ Cannot connect â€” check your API keys in the Keys tab');
  }
}

async function fetchBalance() {
  const data = await demoGET('/fapi/v2/account');
  if (!data || !data.assets) return null;

  const usdt = data.assets.find(a => a.asset === 'USDT');
  if (usdt) {
    const wallet = parseFloat(usdt.walletBalance);
    const upnl   = parseFloat(usdt.unrealizedProfit);
    const margin = parseFloat(usdt.initialMargin);

    // Update top bar only (raw Binance values)
    setText('acctBal',    '$'+wallet.toFixed(2));
    setText('acctUpnl',   (upnl>=0?'+':'')+'$'+upnl.toFixed(2));
    setText('acctMargin', '$'+margin.toFixed(2));
    document.getElementById('acctUpnl').style.color = upnl>=0?'var(--green)':'var(--red)';

    // Store Binance open PnL as authoritative â€” updateDash reads this
    // This eliminates double-write conflict between fetchBalance and updateDash
    st.liveOpenPnl = upnl;
    st.capital     = wallet;

    // Trigger a full dash refresh now that we have fresh Binance data
    updateDash();
  }
  return data;
}

function startBalancePolling() {
  clearInterval(st.balanceInterval);
  st.balanceInterval = setInterval(fetchBalance, 15_000);
}

function updateAPIStatus() {
  document.getElementById('apiStatus').textContent =
`Status:    Connected âœ“
Endpoint:  demo-fapi.binance.com
API Key:   ${st.apiKey.substring(0,8)}â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢
Strategy:  ${st.cfg.strategy.toUpperCase()}
Leverage:  ${st.cfg.leverage}x
Trade Size:$${st.cfg.size}`;
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// WEBSOCKET PRICE STREAMS (public â€” no auth needed, no CORS)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function startPriceStream() {
  // Combined mini-ticker + kline streams
  connectTickerWS();
  SYMBOLS.forEach(sym => connectKlineWS(sym));
  log('ğŸ“¡ WebSocket price streams opened', 'info');
}

function connectTickerWS() {
  const streams = SYMBOLS.map(s => s.toLowerCase() + '@miniTicker').join('/');
  const ws = new WebSocket(`${WS_STREAM}?streams=${streams}`);

  ws.onopen = () => {
    log('ğŸ“ˆ Live prices connected','ok');
    // Load historical candles immediately
    (async()=>{
      log('ğŸ“¥ Loading candles for '+SYMBOLS.length+' symbolsâ€¦','info');
      let done=0;
      const PROXY = 'https://corsproxy.io/?';
      const FAPI  = 'https://fapi.binance.com/fapi/v1/klines';
      const SAPI  = 'https://api.binance.com/api/v3/klines';

      async function fetchCandles(sym) {
        // Try 4 endpoints in order â€” stop at first success
        const endpoints = [
          FAPI+'?symbol='+sym+'&interval=5m&limit=500',
          SAPI+'?symbol='+sym+'&interval=5m&limit=500',
          PROXY+encodeURIComponent(FAPI+'?symbol='+sym+'&interval=5m&limit=500'),
          PROXY+encodeURIComponent(SAPI+'?symbol='+sym+'&interval=5m&limit=500'),
        ];
        for (const url of endpoints) {
          try {
            const r = await fetch(url, {signal: AbortSignal.timeout(8000)});
            const d = await r.json();
            if (Array.isArray(d) && d.length > 10) {
              return d.map(k=>({open:+k[1],high:+k[2],low:+k[3],close:+k[4],vol:+k[5],closed:true}));
            }
          } catch(e) { /* try next endpoint */ }
        }
        return null; // all 4 failed
      }

      for(const sym of SYMBOLS){
        const candles = await fetchCandles(sym);
        if (candles) {
          st.candles[sym] = candles;
          st.wsReady[sym] = true;
          done++;
        } else {
          log('âš ï¸ '+sym+': all endpoints failed â€” will retry','warn');
          fetchFailCount[sym] = (fetchFailCount[sym]||0)+1;
        }
        await new Promise(r=>setTimeout(r,60));
      }

      // Retry failed symbols once after a short delay
      const failed = SYMBOLS.filter(s => !st.wsReady[s]);
      if (failed.length > 0) {
        log('ğŸ”„ Retrying '+failed.length+' failed symbolsâ€¦','info');
        await new Promise(r=>setTimeout(r,3000));
        for (const sym of failed) {
          const candles = await fetchCandles(sym);
          if (candles) {
            st.candles[sym] = candles;
            st.wsReady[sym] = true;
            done++;
            log('âœ… Retry success: '+sym,'ok');
          }
          await new Promise(r=>setTimeout(r,200));
        }
      }
      log('âœ… '+done+' symbols ready â€” scanning now!','ok');
      if(st.connected) setBanner('ok','ğŸŸ¢ Connected to Binance Demo â€” '+done+' symbols loaded!');
      loadTopGainers().then(()=>runScan());
      if(st.running) botLoop();
    })();
  };
  ws.onmessage = e => {
    try {
      const d = JSON.parse(e.data).data;
      if (!d?.s || !SYMBOLS.includes(d.s)) return;
      st.prices[d.s]    = parseFloat(d.c);
      st.change24h[d.s] = parseFloat(d.P);
      st.wsTicks++;
      setText('ws-ticks', st.wsTicks);
      updateTicker();
      if (st.running) { updatePnl(); renderOpenPos(); }
    } catch(e){}
  };
  ws.onerror = () => {};
  ws.onclose = () => { setTimeout(connectTickerWS, 5000); };
  st.ws = ws;
}

function connectKlineWS(sym) {
  const ws = new WebSocket(`wss://stream.binance.com:9443/ws/${sym.toLowerCase()}@kline_5m`);
  ws.onmessage = e => {
    try {
      const k = JSON.parse(e.data).k;
      if (!k) return;
      const candle = { open:parseFloat(k.o), high:parseFloat(k.h), low:parseFloat(k.l), close:parseFloat(k.c), vol:parseFloat(k.v), closed:k.x };
      if (!st.candles[sym]) st.candles[sym] = [];
      if (candle.closed) {
        st.candles[sym].push(candle);
        if (st.candles[sym].length > 100) st.candles[sym].shift();
        st.wsReady[sym] = st.candles[sym].length >= 20;
      } else {
        const arr = st.candles[sym];
        if (arr.length > 0) arr[arr.length-1] = candle; else arr.push(candle);
      }
    } catch(e){}
  };
  ws.onerror = () => {};
  ws.onclose = () => { setTimeout(() => connectKlineWS(sym), 5000); };
  st.wsKlines[sym] = ws;
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// INDICATORS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function rsi(candles, p=14) {
  if (candles.length < p+1) return 50;
  let g=0,l=0;
  for (let i=candles.length-p; i<candles.length; i++) {
    const d=candles[i].close-candles[i-1].close;
    if(d>0) g+=d; else l-=d;
  }
  return 100-100/(1+g/(l||.0001));
}
function ema(arr,n){ const k=2/(n+1);let e=arr[0];for(let i=1;i<arr.length;i++)e=arr[i]*k+e*(1-k);return e; }
function macd(c){ const cl=c.map(x=>x.close); return cl.length>=26?ema(cl,12)-ema(cl,26):0; }
function volSpike(c){ if(c.length<11)return 1; const v=c.slice(-11).map(x=>x.vol),avg=v.slice(0,-1).reduce((a,b)=>a+b,0)/10; return v[v.length-1]/(avg||1); }

// â”€â”€ ADVANCED INDICATORS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function stoch(c,k=14,d=3){
  if(c.length<k) return{k:50,d:50};
  const hi=Math.max(...c.slice(-k).map(x=>x.high));
  const lo=Math.min(...c.slice(-k).map(x=>x.low));
  const kv=((c[c.length-1].close-lo)/(hi-lo||1))*100;
  return{k:kv,d:kv}; // simplified
}
function atr(c,p=14){
  if(c.length<p+1) return 0;
  let sum=0;
  for(let i=c.length-p;i<c.length;i++){
    const h=c[i].high,l=c[i].low,pc=c[i-1].close;
    sum+=Math.max(h-l,Math.abs(h-pc),Math.abs(l-pc));
  }
  return sum/p;
}
// â”€â”€ DYNAMIC LEVERAGE BASED ON VOLATILITY â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// ATR% = ATR/price â€” measures how volatile the coin is right now
// High volatility (wild altcoins) â†’ low leverage to avoid liquidation
// Low volatility (BTC, ETH trending) â†’ high leverage to maximise returns
function getDynamicLeverage(sym) {
  const c = st.candles[sym];
  const price = st.prices[sym];
  if (!c || c.length < 20 || !price) return st.cfg.leverage;

  const atrVal = atr(c, 14);
  const atrPct = (atrVal / price) * 100; // ATR as % of price

  // Volatility tiers:
  // Very low  < 0.3%  â†’ 20x (BTC/ETH in calm market)
  // Low       0.3-0.6% â†’ 15x
  // Medium    0.6-1.2% â†’ 10x
  // High      1.2-2.5% â†’ 6x
  // Very high 2.5-5%  â†’ 4x
  // Extreme   > 5%    â†’ 3x (meme coins, small caps)
  let lev;
  if      (atrPct < 0.3)  lev = 20;
  else if (atrPct < 0.6)  lev = 15;
  else if (atrPct < 1.2)  lev = 10;
  else if (atrPct < 2.5)  lev = 6;
  else if (atrPct < 5.0)  lev = 4;
  else                     lev = 3;

  // cfg.leverage = user's BASE/MINIMUM. Dynamic can go higher for low-vol coins.
  // But never exceed 20x absolute max for safety
  lev = Math.max(lev, st.cfg.leverage); // at least user's configured leverage
  lev = Math.min(lev, 20);              // never exceed 20x

  return lev;
}

function bollingerBands(cl,p=20,mult=2){
  if(cl.length<p) return{upper:cl[cl.length-1],lower:cl[cl.length-1],mid:cl[cl.length-1]};
  const slice=cl.slice(-p);
  const mid=slice.reduce((a,b)=>a+b,0)/p;
  const std=Math.sqrt(slice.reduce((a,b)=>a+(b-mid)**2,0)/p);
  return{upper:mid+mult*std,lower:mid-mult*std,mid};
}
function ema50(cl){ return ema(cl,50); }

// â”€â”€ HIGH-PROBABILITY SIGNAL ENGINE â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Requires 3+ confluences to fire â€” much higher win rate
function getSignal(sym) {
  const c=st.candles[sym]; if(!c||c.length<50) return null;
  const cl=c.map(x=>x.close), cur=cl[cl.length-1];
  const prev=cl[cl.length-2], prev2=cl[cl.length-3];
  try {
    // Core indicators
    const r14   = rsi(c,14);
    const r7    = rsi(c,7);  // faster RSI
    const e9    = ema(cl,9);
    const e21   = ema(cl,21);
    const e50   = ema(cl.slice(-60),50);
    const m     = macd(c);
    const vs    = volSpike(c);
    const bb    = bollingerBands(cl);
    const atrV  = atr(c,14);
    const st2   = stoch(c);
    const mom5  = cur - cl[cl.length-6];  // 5-candle momentum
    const mom3  = cur - cl[cl.length-4];  // 3-candle momentum

    // â”€â”€ CONFLUENCE SCORING â”€â”€
    // Each check is a high-quality signal â€” need 3+ for trade
    let bullSignals=[], bearSignals=[];

    // 1. RSI conditions
    if(r14<35 && r7<30) bullSignals.push('RSI oversold('+r14.toFixed(0)+')');
    if(r14>65 && r7>70) bearSignals.push('RSI overbought('+r14.toFixed(0)+')');
    if(r14>45 && r14<60 && r7>r14) bullSignals.push('RSI bullish momentum');
    if(r14>40 && r14<55 && r7<r14) bearSignals.push('RSI bearish momentum');

    // 2. EMA trend alignment
    if(e9>e21 && e21>e50 && cur>e9) bullSignals.push('EMA aligned bull');
    if(e9<e21 && e21<e50 && cur<e9) bearSignals.push('EMA aligned bear');
    if(e9>e21 && cur>e21) bullSignals.push('EMA9>EMA21');
    if(e9<e21 && cur<e21) bearSignals.push('EMA9<EMA21');

    // 3. MACD
    if(m>0 && m>macd({candles:c.slice(0,-1),map:x=>x})) bullSignals.push('MACD+ rising');
    if(m<0) bearSignals.push('MACD negative');
    if(m>0) bullSignals.push('MACD positive');

    // 4. Bollinger Bands
    if(cur<bb.lower*1.002) bullSignals.push('BB oversold bounce');
    if(cur>bb.upper*0.998) bearSignals.push('BB overbought');
    if(cur>bb.mid && prev<bb.mid) bullSignals.push('BB midline cross up');
    if(cur<bb.mid && prev>bb.mid) bearSignals.push('BB midline cross down');

    // 5. Volume confirmation
    if(vs>2.0 && cur>prev) bullSignals.push('High vol bull candle('+vs.toFixed(1)+'x)');
    if(vs>2.0 && cur<prev) bearSignals.push('High vol bear candle('+vs.toFixed(1)+'x)');
    if(vs>1.3 && cur>prev) bullSignals.push('Vol confirmed up');
    if(vs>1.3 && cur<prev) bearSignals.push('Vol confirmed down');

    // 6. Momentum
    if(mom5>0 && mom3>0 && cur>prev) bullSignals.push('Strong momentum up');
    if(mom5<0 && mom3<0 && cur<prev) bearSignals.push('Strong momentum down');

    // 7. Candlestick patterns
    const body=Math.abs(cur-c[c.length-1].open);
    const range=c[c.length-1].high-c[c.length-1].low;
    if(body>range*0.6 && cur>c[c.length-1].open) bullSignals.push('Bull candle body');
    if(body>range*0.6 && cur<c[c.length-1].open) bearSignals.push('Bear candle body');

    // 8. Price action vs 50 EMA
    if(cur>e50 && prev2<e50) bullSignals.push('50EMA breakout');
    if(cur<e50 && prev2>e50) bearSignals.push('50EMA breakdown');

    // â”€â”€ DECISION: need minimum 3 confluences â”€â”€
    const minConf = 3;

    // Anti-bias guard: don't short oversold coins, don't long overbought
    const rsiBlock = (dir, r) => {
      if(dir==='SHORT' && r14<40) return true; // RSI too low to short
      if(dir==='LONG'  && r14>60) return true; // RSI too high to long
      return false;
    };

    if(bullSignals.length>=minConf && bullSignals.length>bearSignals.length+1 && !rsiBlock('LONG',r14)){
      const conf=Math.min(50+bullSignals.length*6,95);
      return{dir:'LONG', conf, reason:bullSignals.slice(0,3).join(' | '), signals:bullSignals.length, atrPct:(atrV/cur*100)};
    }
    if(bearSignals.length>=minConf && bearSignals.length>bullSignals.length+1 && !rsiBlock('SHORT',r14)){
      const conf=Math.min(50+bearSignals.length*6,95);
      return{dir:'SHORT', conf, reason:bearSignals.slice(0,3).join(' | '), signals:bearSignals.length, atrPct:(atrV/cur*100)};
    }
    // Weak signal
    if(bullSignals.length>bearSignals.length && !rsiBlock('LONG',r14))
      return{dir:'LONG', conf:40+bullSignals.length*4, reason:'Weak: '+bullSignals.slice(0,2).join(', '), signals:bullSignals.length, weak:true};
    if(bearSignals.length>bullSignals.length && !rsiBlock('SHORT',r14))
      return{dir:'SHORT', conf:40+bearSignals.length*4, reason:'Weak: '+bearSignals.slice(0,2).join(', '), signals:bearSignals.length, weak:true};
    return null;
  } catch(e){ return null; }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ORDER PLACEMENT ON BINANCE DEMO
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
async function setLeverage(sym, lev) {
  // Always use CROSS margin (not isolated) â€” ignore errors if already set
  try { await demoPOST('/fapi/v1/marginType', { symbol: sym, marginType: 'CROSSED' }); } catch(e) {}
  return await demoPOST('/fapi/v1/leverage', { symbol:sym, leverage:lev });
}

// Symbols unavailable or renamed on Binance Futures
// Only skip symbols that are genuinely delisted or renamed on Binance Futures
const SKIP_SYMBOLS = new Set([
  'FTMUSDT',     // delisted
  'LUNA2USDT',   // delisted
  'LUNAUSDT',    // delisted
  'STABLEUSDT',  // not a trading pair
  'MATICUSDT',   // renamed to POLUSDT
  'BTCDOMUSDT',  // index, not tradeable
  'ICPUSDT',     // Symbol is closed on futures
  'XAGUSDT',     // Silver spot â€” not futures
  'MKRUSDT',     // Invalid symbol status
]);
const RENAME_SYMBOLS = {'SHIBUSDT':'1000SHIBUSDT','PEPEUSDT':'1000PEPEUSDT','BONKUSDT':'1000BONKUSDT','FLOKIUSDT':'1000FLOKIUSDT'};
// Transient fail tracker â€” just for logging, never blocks trading
const fetchFailCount = {};

async function placeOrder(sym, dir, size) {
  // Remap symbols that have different names on futures
  if (RENAME_SYMBOLS[sym]) { sym = RENAME_SYMBOLS[sym]; }
  // Guard: all early exits BEFORE acquiring the pending lock
  if (SKIP_SYMBOLS.has(sym))                        { return; }
  if (!st.connected)                                { toast('Not connected'); return; }
  if (st.tradeCount >= st.cfg.maxTrades)            { return; }
  if (st.togs.dlg && st.todayLoss >= (st.cfg.startCapital||1000)*0.2) { return; } // 20% daily loss limit
  // Already have an open position for this symbol?
  if (st.openPos.find(t => t.sym === sym))          { return; }

  // Acquire pending lock â€” prevents race condition duplicate orders
  if (!st.pendingOrder) st.pendingOrder = new Set();
  if (st.pendingOrder.has(sym)) {
    log('â³ '+sym+' order already pending â€” skip','warn');
    return;
  }
  st.pendingOrder.add(sym);

  // Safety: always release lock if anything throws unexpectedly
  try {

  const price = st.prices[sym];
  if (!price) {
    st.pendingOrder.delete(sym);
    log('No live price for '+sym,'warn');
    return;
  }

  const slip     = st.togs.slip ? 0.0005 : 0;
  const entry    = price * (dir==='BUY' ? 1+slip : 1-slip);
  const lev      = getDynamicLeverage(sym);  // Dynamic: ATR-based volatility leverage
  const notional = size * lev;
  const tpDist   = st.cfg.tp / notional;
  const slDist   = st.cfg.sl / notional;
  const tpPrice  = dir==='BUY' ? entry*(1+tpDist) : entry*(1-tpDist);
  const slPrice  = dir==='BUY' ? entry*(1-slDist) : entry*(1+slDist);

  // Set leverage first
  await setLeverage(sym, lev);

  // Calculate quantity with proper Binance futures lot size precision
  const rawQty = notional / entry;
  let qty;
  if      (entry >= 10000) qty = Math.floor(rawQty * 1000) / 1000;   // BTC: 3dp
  else if (entry >= 1000)  qty = Math.floor(rawQty * 100) / 100;     // ETH: 2dp
  else if (entry >= 100)   qty = Math.floor(rawQty * 10) / 10;       // BNB: 1dp
  else if (entry >= 10)    qty = Math.floor(rawQty * 1) / 1;         // SOL: 0dp
  else if (entry >= 1)     qty = Math.floor(rawQty * 1) / 1;         // NEAR, ATOM: 0dp
  else if (entry >= 0.1)   qty = Math.floor(rawQty * 1) / 1;         // DOGE, ADA: 0dp
  else                     qty = Math.floor(rawQty / 10) * 10;       // SHIB, PEPE: round to 10s
  if (qty <= 0) { st.pendingOrder.delete(sym); log('âŒ Qty too small for '+sym,'err'); return; }

  log('ğŸ“¤ '+dir+' '+qty+' '+sym+' @ ~$'+fmt(entry)+' | '+lev+'x | TP $'+fmt(tpPrice)+' | SL $'+fmt(slPrice), 'info');

  // Place market order on demo-fapi
  const order = await demoPOST('/fapi/v1/order', {
    symbol: sym, side: dir,
    type: 'MARKET', quantity: qty,
    positionSide: 'BOTH'
  });

  if (!order || !order.orderId) {
    st.pendingOrder.delete(sym); // always release lock on failure
    const errMsg = (order && order.msg) ? order.msg : 'unknown';
    // Auto-skip permanently broken symbols
    if (errMsg.includes('Symbol is closed') || errMsg.includes('Invalid symbol')) {
      SKIP_SYMBOLS.add(sym);
      log('ğŸš« Auto-skipping '+sym+' permanently: '+errMsg,'warn');
    }
    log('âŒ Order failed for '+sym+': '+errMsg,'err');
    return;
  }

  log(`âœ… DEMO ORDER FILLED: ${order.side} ${order.origQty} ${sym} | OrderID: ${order.orderId}`, 'ok');

  // TP/SL â€” monitored locally (demo API doesn't support conditional order types)
  log('ğŸ¯ TP @ $'+fmt(tpPrice)+' | SL @ $'+fmt(slPrice)+' (local monitor active)', 'ok');

  // Track locally
  // Capture current signal info at trade open time
  const curSigAtOpen = st.wsReady[sym] ? getSignal(sym) : null;
  const trade = {
    id: order.orderId, sym, dir,
    size, lev, price: entry, notional,
    tpPrice, slPrice,
    qty, orderId: order.orderId,
    reason: curSigAtOpen ? curSigAtOpen.reason : 'Manual order',
    openReason: curSigAtOpen ? curSigAtOpen.reason : 'Manual order',
    openConf: curSigAtOpen ? curSigAtOpen.conf : null,
    signals: curSigAtOpen ? curSigAtOpen.signals : null,
    time: new Date().toLocaleTimeString(),
    openTime: new Date().toLocaleTimeString(),
    openTimestamp: Date.now(),
    _ts: Date.now(),
    status: 'OPEN', pnl: 0
  };
  } catch(e) {
    st.pendingOrder.delete(sym);
    log('âŒ Unexpected error placing order for '+sym+': '+e.message,'err');
    return;
  }
  st.pendingOrder.delete(sym);
  st.openPos.push(trade);
  st.allTrades.unshift(trade);
  st.tradeCount++;
  st.capital -= size;

  saveState(); updateDash(); renderOpenPos();
  toast(`Demo ${dir==='BUY'?'LONG':'SHORT'} placed on Binance!`);
}

function confirmClose(id) {
  const sid = String(id);
  const trade = st.openPos.find(t => String(t.id) === sid || String(t.orderId) === sid);
  if (!trade) {
    // Check if it's stale in allTrades â€” mark as closed and remove
    const stale = st.allTrades.find(t => (String(t.id)===sid||String(t.orderId)===sid) && t.status==='OPEN');
    if (stale) {
      stale.status = 'LOSS'; stale.closeReason = 'Stale â€” removed';
      saveState(); renderTrades(); renderOpenPos();
      log('ğŸ—‘ Removed stale trade '+stale.sym+' (not on Binance)','warn');
      toast('Stale trade removed â€” sync Binance to refresh');
    } else {
      log('Close failed â€” position not found: '+id,'warn');
      toast('Not found â€” tap Sync Binance');
    }
    return;
  }
  const pnl = trade.pnl || 0;
  const sym = trade.sym.replace('USDT','/USDT');
  const dir = trade.dir==='BUY'?'LONG':'SHORT';
  if (confirm('Close ' + sym + ' ' + dir + '?\nCurrent PnL: ' + (pnl>=0?'+':'') + '$' + pnl.toFixed(2))) {
    closePosition(trade);
  }
}

async function closeAllPositions() {
  if (!st.openPos.length) { toast('No open positions'); return; }
  const totalPnl = st.openPos.reduce((s,t)=>s+t.pnl,0);
  const msg = 'Close ALL '+st.openPos.length+' positions?\nTotal PnL: '+(totalPnl>=0?'+':'')+'$'+totalPnl.toFixed(2);
  if (!confirm(msg)) return;
  toast('Closing all positionsâ€¦');
  const toClose = [...st.openPos];
  let closed = 0;
  for (const t of toClose) {
    await closePosition(t);
    closed++;
    await new Promise(r=>setTimeout(r,600)); // small delay between each
  }
  toast('Closed '+closed+' positions');
}

// Emergency close â€” cancel all open orders then close all positions on Binance
async function emergencyCloseAll() {
  if (!confirm('EMERGENCY CLOSE ALL?\nThis cancels all orders and closes everything on Binance.')) return;
  toast('ğŸš¨ Emergency close startedâ€¦');
  log('ğŸš¨ EMERGENCY CLOSE ALL initiated','err');
  // Cancel all open orders globally
  try {
    const syms = [...new Set(st.openPos.map(t=>t.sym))];
    for (const sym of syms) {
      await demoPOST('/fapi/v1/allOpenOrders', { symbol: sym });
      await new Promise(r=>setTimeout(r,200));
    }
  } catch(e) {}
  // Close all positions
  const toClose = [...st.openPos];
  for (const t of toClose) {
    await closePosition(t);
    await new Promise(r=>setTimeout(r,600));
  }
  // Sync from Binance to confirm
  await syncPositionsFromBinance();
  toast('Emergency close complete â€” check Binance to confirm');
}

async function closePosition(trade) {
  const sym = trade.sym;
  const closeSide = trade.dir==='BUY' ? 'SELL' : 'BUY';

  log('ğŸ”„ Closing '+sym+'â€¦', 'info');

  // STEP 1: Cancel ALL open orders for this symbol first
  // This clears any stale reduceOnly orders that block new closes
  try {
    await demoPOST('/fapi/v1/allOpenOrders', { symbol: sym });
    log('ğŸ—‘ Cancelled open orders for '+sym, 'info');
  } catch(e) { /* no open orders â€” fine */ }

  // STEP 2: Get real position size from Binance
  let qty = trade.qty;
  let positionExists = false;
  try {
    const risk = await demoGET('/fapi/v2/positionRisk', {symbol: sym});
    if (Array.isArray(risk)) {
      const pos = risk.find(p => p.symbol === sym);
      if (pos) {
        const realAmt = Math.abs(parseFloat(pos.positionAmt));
        if (realAmt > 0) { qty = realAmt; positionExists = true; }
        else {
          // Position already closed on Binance â€” just clean up locally
          log('â„¹ï¸ '+sym+' already closed on Binance â€” cleaning local state', 'info');
          const cur = st.prices[sym] || trade.price;
          const pd  = (cur - trade.price) / trade.price;
          const pnl = trade.dir==='BUY' ? trade.notional*pd : -trade.notional*pd;
          recordClose(trade, pnl, 'Manual close');
          return;
        }
      }
    }
  } catch(e) {
    log('âš ï¸ Could not verify position for '+sym+': '+e.message, 'warn');
    positionExists = true; // assume it exists, try anyway
  }

  // STEP 3: Place market close order â€” NO reduceOnly
  const order = await demoPOST('/fapi/v1/order', {
    symbol: sym,
    side: closeSide,
    type: 'MARKET',
    quantity: qty,
    positionSide: 'BOTH'
    // NO reduceOnly â€” it causes "reduce-only order failed" errors
  });

  // STEP 4: Only mark closed locally if Binance confirmed it
  if (order && order.orderId) {
    const cur = st.prices[sym] || trade.price;
    const pd  = (cur - trade.price) / trade.price;
    const pnl = trade.dir==='BUY' ? trade.notional*pd : -trade.notional*pd;
    recordClose(trade, pnl, 'Manual close');
    log('âœ… '+sym+' closed on Binance | PnL: '+(pnl>=0?'+':'')+'$'+pnl.toFixed(2), pnl>=0?'ok':'warn');
    toast(sym.replace('USDT','')+' closed '+(pnl>=0?'â–²+$':'â–¼$')+Math.abs(pnl).toFixed(2));
  } else {
    // DO NOT call recordClose â€” position is still open on Binance
    log('âŒ Close FAILED for '+sym+' â€” still open on Binance. Try again or close manually.', 'err');
    toast('âŒ '+sym.replace('USDT','')+' close failed â€” try again');
    closingGuard.delete(String(trade.id)); // release guard so retry works
  }
}

function saveState() {
  try {
    localStorage.setItem('demoTrades', JSON.stringify(st.allTrades.slice(0,100)));
    localStorage.setItem('demoOpenPos', JSON.stringify(st.openPos));
    localStorage.setItem('demoStats', JSON.stringify({wins:st.wins,losses:st.losses,totalPnl:st.totalPnl,tradeCount:st.tradeCount}));
  } catch(e){}
}

function loadState() {
  try {
    localStorage.removeItem('blockedSyms'); // cleanup old blocking
    const trades = localStorage.getItem('demoTrades');
    const open   = localStorage.getItem('demoOpenPos');
    const stats  = localStorage.getItem('demoStats');
    if (trades) st.allTrades = JSON.parse(trades);
    if (open)   st.openPos   = JSON.parse(open);
    if (stats) {
      const s=JSON.parse(stats);
      st.wins=s.wins||0; st.losses=s.losses||0;
      st.tradeCount=s.tradeCount||0;
      // Recompute totalPnl from allTrades rather than trusting saved counter
      st.totalPnl = st.allTrades.filter(t=>t.status!=='OPEN').reduce((s,t)=>s+(t.pnl||0),0);
    }
    if (st.openPos.length) log('ğŸ“‚ Restored '+st.openPos.length+' open positions from last session','ok');
  } catch(e){}
}

function recordClose(trade, pnl, reason) {
  // Remove from open positions
  st.openPos = st.openPos.filter(t => String(t.id) !== String(trade.id));
  closingGuard.delete(String(trade.id)); // allow re-use of ID if needed
  // Update trade record
  trade.status = pnl>=0?'WIN':'LOSS';
  trade.pnl    = pnl;
  trade.closeTime = new Date().toLocaleTimeString();
  trade.closeTimestamp = Date.now();
  trade.closeReason = reason; // 'Stop Loss', 'Take Profit', or 'Manual close'
  // Duration logging
  if (trade.openTimestamp) {
    var mins = Math.round((trade.closeTimestamp - trade.openTimestamp)/60000);
    var dur = mins >= 60 ? Math.floor(mins/60)+'h '+(mins%60)+'m' : mins+'m';
    log('â± '+trade.sym+' held for '+dur+' | Reason: '+reason, 'info');
  }
  // SL root cause analysis log
  if (reason === 'Stop Loss') {
    log('ğŸ“‹ SL Root Cause ['+trade.sym+']: Entry '+fmt(trade.price)+
        ' â†’ Exit '+fmt(st.prices[trade.sym]||trade.price)+
        ' | Dir: '+(trade.dir==='BUY'?'LONG':'SHORT')+
        ' | Opened: '+(trade.openConf||'?')+'% conf Â· '+(trade.signals||'?')+' signals'+
        ' | Reason: '+(trade.openReason||'unknown'), 'err');
  }
  // Make sure it's in allTrades
  if (!st.allTrades.find(t => String(t.id)===String(trade.id))) {
    st.allTrades.unshift(trade);
  } else {
    const idx = st.allTrades.findIndex(t => String(t.id)===String(trade.id));
    if (idx >= 0) st.allTrades[idx] = trade;
  }
  // Update stats â€” totalPnl derived from allTrades, not incremented here
  st.todayPnl += pnl;
  if (pnl >= 0) { st.wins++; } else { st.losses++; st.todayLoss += Math.abs(pnl); }
  // Keep totalPnl in sync by recomputing from closed trades (single source of truth)
  st.totalPnl = st.allTrades.filter(t=>t.status!=='OPEN').reduce((s,t)=>s+(t.pnl||0),0);
  st.pnlHistory.push(st.totalPnl);
  log((pnl>=0?'ğŸ’°':'ğŸ”´')+' CLOSED '+trade.sym+': '+(pnl>=0?'+':'')+'$'+pnl.toFixed(2)+' | '+reason, pnl>=0?'ok':'err');
  saveState();
  updateDash(); renderOpenPos(); renderTrades(); drawPnlChart();
}

async function syncPositionsFromBinance() {
  // Binance is always ground truth â€” clean up any ghost positions
  // Pull REAL open positions + unrealised PnL directly from Binance Demo
  if (!st.connected) return;
  try {
    const data = await demoGET('/fapi/v2/positionRisk');
    if (!data || !Array.isArray(data)) return;

    const active = data.filter(p => parseFloat(p.positionAmt) !== 0);

    if (active.length === 0) {
      // Binance has no open positions â€” close any we tracked locally as orphans
      if (st.openPos.length > 0) {
        log('ğŸ“¡ Binance: no open positions â€” clearing local orphans','warn');
        st.openPos = [];
        saveState(); renderOpenPos(); updateDash();
      }
      return;
    }

    // Update or add each real Binance position
    let changed = false;
    for (const pos of active) {
      const sym   = pos.symbol;
      const amt   = parseFloat(pos.positionAmt);
      const entry = parseFloat(pos.entryPrice);
      const upnl  = parseFloat(pos.unRealizedProfit);
      const dir   = amt > 0 ? 'BUY' : 'SELL';
      const lev   = parseFloat(pos.leverage) || getDynamicLeverage(sym);
      const notional = Math.abs(amt) * entry;

      // Find matching local position
      let local = st.openPos.find(t => t.sym === sym);
      if (local) {
        // Update PnL from REAL Binance unrealizedProfit (most accurate)
        local.pnl   = upnl;
        local.lev   = lev;
        local.price = local.price || entry;
        local.qty   = Math.abs(parseFloat(pos.positionAmt)); // sync real qty too
      } else {
        // Position exists on Binance but not locally â€” add it
        log('ğŸ“¡ Found Binance position not tracked locally: '+sym+' '+dir,'warn');
        const tpDist = st.cfg.tp / notional;
        const slDist = st.cfg.sl / notional;
        st.openPos.push({
          id: sym+'_'+Date.now(), sym, dir,
          size: st.cfg.size, lev, price: entry, notional,
          tpPrice: dir==='BUY' ? entry*(1+tpDist) : entry*(1-tpDist),
          slPrice:  dir==='BUY' ? entry*(1-slDist) : entry*(1+slDist),
          qty: Math.abs(amt),
          orderId: 'binance_sync',
          reason: 'Synced from Binance',
          time: new Date().toLocaleTimeString(),
          status: 'OPEN', pnl: upnl
        });
        changed = true;
      }
    }

    // Remove locally tracked positions that are no longer on Binance
    const activeSyms = active.map(p=>p.symbol);
    const before = st.openPos.length;
    st.openPos = st.openPos.filter(t => {
      if (activeSyms.includes(t.sym)) return true;
      // Position closed on Binance â€” record it
      log('ğŸ“¡ '+t.sym+' closed on Binance (TP/SL hit) | PnL: '+(t.pnl>=0?'+':'')+'$'+t.pnl.toFixed(2), t.pnl>=0?'ok':'warn');
      t.status = t.pnl >= 0 ? 'WIN' : 'LOSS';
      if (!st.allTrades.find(x=>x.id===t.id)) st.allTrades.unshift(t);
      if (t.pnl >= 0) st.wins++; else { st.losses++; st.todayLoss += Math.abs(t.pnl); }
      st.todayPnl += t.pnl;
      // Do NOT increment st.totalPnl here â€” updateDash derives it from allTrades
      return false;
    });
    if (st.openPos.length !== before) changed = true;
    if (changed) { saveState(); renderTrades(); }

  } catch(e) {
    log('Sync error: '+e.message,'warn');
  }
}

// Guard to prevent double-firing SL/TP
const closingGuard = new Set();

function updatePnl() {
  // Called on every price tick â€” only updates PnL numbers, no closes
  for (const t of st.openPos) {
    const cur = st.prices[t.sym];
    if (!cur) continue;
    const pd = (cur - t.price) / t.price;
    t.pnl = t.dir==='BUY' ? t.notional * pd : -(t.notional * pd);
  }
}

function monitorOpenPositions() {
  // Called every 2s from interval â€” checks TP/SL and triggers closes
  const snapshot = [...st.openPos]; // copy so removals don't affect iteration
  for (const t of snapshot) {
    const cur = st.prices[t.sym];
    if (!cur) continue;

    // Update live PnL
    const pd = (cur - t.price) / t.price;
    t.pnl = t.dir==='BUY' ? t.notional * pd : -(t.notional * pd);

    // Skip if already being closed
    if (closingGuard.has(String(t.id))) continue;

    // Only check TP/SL if toggle is on
    if (!st.togs.tpsl) continue;

    const hitTP = t.dir==='BUY' ? cur >= t.tpPrice : cur <= t.tpPrice;
    const hitSL = t.dir==='BUY' ? cur <= t.slPrice : cur >= t.slPrice;

    if (hitTP || hitSL) {
      closingGuard.add(String(t.id)); // lock it immediately
      const reason = hitTP ? 'Take Profit' : 'Stop Loss';
      const emoji  = hitTP ? 'ğŸ¯' : 'â›”';
      log(emoji+' '+reason+' HIT: '+t.sym+
          ' | Entry $'+fmt(t.price)+' | Exit $'+fmt(cur)+
          ' | PnL: '+(t.pnl>=0?'+':'')+'$'+t.pnl.toFixed(2), hitTP?'ok':'err');
      // Close on Binance â€” only recordClose if confirmed
      (async () => {
        try {
          await demoPOST('/fapi/v1/allOpenOrders', { symbol: t.sym });
        } catch(e) {}
        const closeSide = t.dir==='BUY' ? 'SELL' : 'BUY';
        const order = await demoPOST('/fapi/v1/order', {
          symbol: t.sym, side: closeSide,
          type: 'MARKET', quantity: t.qty,
          positionSide: 'BOTH'
        });
        if (order && order.orderId) {
          recordClose(t, t.pnl, reason);
        } else {
          closingGuard.delete(String(t.id)); // retry next cycle
          log('âš ï¸ '+reason+' order failed for '+t.sym+' â€” will retry','warn');
        }
      })();
    }
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// BOT LOOP
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
async function botLoop() {
  if (!st.running) return;
  st.tickStep++;

  if (!st.connected)                               { log('Not connected to Binance Demo','warn'); return; }
  if (st.tradeCount >= st.cfg.maxTrades)           { log('Daily trade limit reached','warn'); return; }
  if (st.togs.dlg && st.todayLoss >= (st.cfg.startCapital||1000)*0.2) { log('â›” Daily loss limit hit ($'+(st.cfg.startCapital||1000)*0.2+'). Bot stopped.','err'); stopBot(); return; }
  if (st.openPos.length >= st.cfg.maxOpen)        return;
  if (!st.togs.auto)                              return;
  if (Object.keys(st.prices).length < 3)          return;

  const syms = shuffle([...SYMBOLS]);
  for (const sym of syms) {
    if (st.openPos.find(t=>t.sym===sym)) continue;
    if (!st.wsReady[sym]) continue;
    const sig = getSignal(sym);
    if (sig && sig.conf >= 62 && !sig.weak) {
      await placeOrder(sym, sig.dir==='LONG'?'BUY':'SELL', st.cfg.size);
      break;
    }
  }
}

function toggleBot() { st.running ? stopBot() : startBot(); }

function startBot() {
  if (!st.connected) {
    toast('Connect your API keys first (Keys tab)');
    nav('setup'); return;
  }
  st.running = true;
  document.getElementById('mainBtn').textContent = 'â¹ STOP BOT';
  document.getElementById('mainBtn').className   = 'btn btn-r';
  document.getElementById('botBadge').textContent  = 'RUNNING';
  document.getElementById('botBadge').className    = 'badge b-run';
  log('ğŸš€ Demo Bot started â€” placing REAL demo orders on Binance!', 'ok');
  st.loopInterval    = setInterval(botLoop, 15_000);
  st.monitorInterval = setInterval(() => { monitorOpenPositions(); renderOpenPos(); updateDash(); }, 2000);
  st.syncInterval    = setInterval(() => { lastSyncTime=Date.now(); syncPositionsFromBinance(); }, 30_000);
  botLoop();
  syncPositionsFromBinance(); // immediate sync on start
}

function stopBot() {
  st.running = false;
  clearInterval(st.loopInterval); clearInterval(st.monitorInterval); clearInterval(st.syncInterval);
  document.getElementById('mainBtn').textContent = 'â–¶ START DEMO BOT';
  document.getElementById('mainBtn').className   = 'btn btn-y';
  document.getElementById('botBadge').textContent  = 'STOPPED';
  document.getElementById('botBadge').className    = 'badge b-off';
  log('â¹ Bot stopped.', 'warn');
}

function resetSession() {
  stopBot();
  Object.assign(st,{capital:2000,todayPnl:0,totalPnl:0,todayLoss:0,tradeCount:0,wins:0,losses:0,openPos:[],allTrades:[],pnlHistory:[0],tickStep:0});
  updateDash(); renderOpenPos(); renderTrades(); drawPnlChart();
  toast('Session reset âœ“');
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// SCANNER
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
let scanMode = 'all';
let gainersCache = [], losersCache = [];

function setScanMode(mode) {
  scanMode = mode;
  ['all','gainers','losers','signals'].forEach(m => {
    const btn = document.getElementById('sf-'+m);
    if (!btn) return;
    btn.style.border = m===mode ? '1px solid var(--accent)' : '1px solid var(--border)';
    btn.style.color  = m===mode ? 'var(--accent)' : '';
  });
  if (mode === 'gainers') loadTopGainers().then(()=>runScan());
  else if (mode === 'losers') loadTopLosers().then(()=>runScan());
  else runScan();
  toast({all:'All coins',gainers:'ğŸ”¥ Top Gainers',losers:'ğŸ“‰ Top Losers',signals:'âš¡ Signal coins only'}[mode]);
}

async function loadTopLosers() {
  try {
    const r=await fetch('https://api.binance.com/api/v3/ticker/24hr');
    const all=await r.json();
    const losers=all
      .filter(t=>t.symbol.endsWith('USDT')&&!t.symbol.includes('_')&&parseFloat(t.quoteVolume)>50000000)
      .sort((a,b)=>parseFloat(a.priceChangePercent)-parseFloat(b.priceChangePercent))
      .slice(0,20).map(t=>t.symbol);
    SYMBOLS=[...new Set([...losers,...SYMBOLS])].slice(0,40);
    losersCache = losers;
    log('ğŸ“‰ Top losers loaded: '+losers.slice(0,5).join(', ')+'â€¦','ok');
  }catch(e){log('Top losers failed: '+e.message,'warn');}
}

function runScan() {
  const searchTerm = (document.getElementById('symSearch')?.value||'').toUpperCase().trim();
  let scanSyms = searchTerm ? SYMBOLS.filter(s=>s.includes(searchTerm)) : SYMBOLS;
  // Apply scan mode filter
  if (scanMode === 'gainers' && gainersCache.length) scanSyms = gainersCache.filter(s=>SYMBOLS.includes(s));
  if (scanMode === 'losers'  && losersCache.length)  scanSyms = losersCache.filter(s=>SYMBOLS.includes(s));
  // Always show all symbols â€” with loading state if candles not ready yet
  const results = scanSyms.map(sym => {
    const cc=st.candles[sym]||[], price=st.prices[sym]||0, chg=st.change24h[sym]||0;
    return { sym, price, chg, rsi:cc.length>=15?rsi(cc):null, vs:cc.length>=11?volSpike(cc):1,
             sig:st.wsReady[sym]?getSignal(sym):null, ready:st.wsReady[sym],
             candleCount: cc.length };
  }).filter(r => scanMode !== 'signals' || (r.sig && r.sig.conf >= 60))
    .sort((a,b) => {
      // Sort: signals first, then by 24h change
      const ac = b.sig?.conf||0, bc2 = a.sig?.conf||0;
      if (ac !== bc2) return ac - bc2;
      return Math.abs(b.chg) - Math.abs(a.chg);
    });

  const el = document.getElementById('scanList');
  if (!results.length && SYMBOLS.length === 0) {
    el.innerHTML = '<div class="empty"><div class="ei">ğŸ”‘</div>Connect API keys to start scanning</div>';
    return;
  }
  if (!results.length) {
    el.innerHTML = '<div class="empty"><div class="ei">â³</div>Loading candlesâ€¦ please wait</div>';
    return;
  }
  el.innerHTML = results.map(r=>{
    const sig=r.sig;
    const cCol=r.chg>=0?'var(--green)':'var(--red)';
    const chipStyle=sig?(sig.dir==='LONG'?'background:rgba(0,230,118,.15);color:var(--green)':'background:rgba(255,77,109,.15);color:var(--red)'):'background:rgba(85,85,112,.15);color:var(--dim)';
    const iconBg=sig?(sig.dir==='LONG'?'rgba(0,230,118,.1)':'rgba(255,77,109,.1)'):'rgba(85,85,112,.1)';
    const dynLev = r.ready ? getDynamicLeverage(r.sym) : st.cfg.leverage;
    const levCol = dynLev>=15?'var(--green)':dynLev>=8?'var(--accent)':dynLev>=5?'var(--yellow)':'var(--red)';
    return `<div class="srow" onclick="openSheet('${r.sym}')">
      <div class="sico" style="background:${iconBg}">${ICONS[r.sym]||r.sym.replace('1000','').replace('USDT','').slice(0,2)}</div>
      <div style="flex:1;min-width:0;overflow:hidden">
        <div style="font-size:13px;font-weight:700;white-space:nowrap;overflow:hidden;text-overflow:ellipsis">${r.sym.replace('USDT','/USDT')} <span style="font-size:10px;color:${levCol};font-family:var(--mono)">${dynLev}x</span></div>
        <div style="font-size:10px;color:var(--dim);margin-top:2px;white-space:nowrap;overflow:hidden;text-overflow:ellipsis">${sig?sig.reason:(r.ready?'No signal':`Loading (${(st.candles[r.sym]||[]).length}/50)`)} Â· ${r.rsi!==null?'RSI '+r.rsi.toFixed(1):(r.candleCount>0?'Loading '+r.candleCount+'/50':'Waitingâ€¦')}</div>
      </div>
      <div style="text-align:right">
        <div style="font-family:var(--mono);font-size:13px;font-weight:700;color:${cCol}">${r.chg>=0?'+':''}${r.chg.toFixed(2)}%</div>
        <div style="display:inline-block;font-size:9px;font-weight:700;padding:2px 7px;border-radius:4px;margin-top:3px;${chipStyle}">${sig?(sig.signals+'âœ“ '+sig.dir+' '+sig.conf+'%'):'WAIT'}</div>
      </div>
    </div>`;
  }).join('');
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// RENDER
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// â”€â”€ Single source of truth for all PnL â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Never read st.totalPnl directly. Always derive from allTrades + live open pnl.
function computePnL() {
  const closed    = st.allTrades.filter(t => t.status !== 'OPEN');
  const closedPnl = closed.reduce((s, t) => s + (t.pnl || 0), 0);
  // Open PnL: use Binance unrealized if available, else sum local estimates
  const openPnl   = typeof st.liveOpenPnl === 'number' ? st.liveOpenPnl
                  : st.openPos.reduce((s, t) => s + (t.pnl || 0), 0);
  const totalPnl  = openPnl + closedPnl;
  const wins      = closed.filter(t => t.pnl > 0).length;
  const losses    = closed.filter(t => t.pnl <= 0).length;
  const wr        = (wins + losses) > 0 ? Math.round(wins / (wins + losses) * 100) : null;
  const best      = closed.length ? Math.max(...closed.map(t => t.pnl)) : null;
  const worst     = closed.length ? Math.min(...closed.map(t => t.pnl)) : null;
  return { closedPnl, openPnl, totalPnl, closed, wins, losses, wr, best, worst };
}

function updateDash() {
  const { closedPnl, openPnl, totalPnl, closed, wins, losses, wr, best, worst } = computePnL();
  const startCap = st.cfg.startCapital || 1000;
  const cap = startCap + closedPnl; // session capital = start + realised only

  // â”€â”€ DASH tab metrics â”€â”€
  setText('s-cap', '$' + cap.toFixed(2));
  const pe = document.getElementById('s-pnl');
  // Session P&L = total (open + closed) so trader sees real-time picture
  pe.textContent = (totalPnl>=0?'+':'')+'$'+totalPnl.toFixed(2);
  pe.className = 'sv ' + (totalPnl>=0?'g':'r');
  setText('s-pct', ((totalPnl/(st.cfg.startCapital||1000))*100).toFixed(2)+'%');
  setText('cap-started', 'Started: $'+(st.cfg.startCapital||1000));
  setText('s-trades', st.tradeCount+'/'+st.cfg.maxTrades);
  setText('s-wr', wr !== null ? wr+'%' : 'â€”');
  setText('s-wl', wins+'W / '+losses+'L (closed)');
  setText('posCount', st.openPos.length+' open');

  const p1 = Math.min(Math.max(closedPnl, 0) / 200 * 100, 100);
  document.getElementById('p1').style.width = p1+'%';
  setText('p1t', '$'+Math.max(closedPnl,0).toFixed(2));
  document.getElementById('p2').style.width = (st.tradeCount/st.cfg.maxTrades*100)+'%';
  setText('p2t', st.tradeCount+'/'+st.cfg.maxTrades);
  document.getElementById('p3').style.width = Math.min(st.todayLoss/200*100,100)+'%';  // $200 max daily loss
  setText('p3t', '$'+st.todayLoss.toFixed(2));

  // â”€â”€ TRADES tab summary â”€â”€
  setText('t-total', st.allTrades.length);
  const tpe = document.getElementById('t-pnl');
  // Trades tab Realised P&L = closed only (matches Dash Closed PnL exactly)
  tpe.textContent = (closedPnl>=0?'+':'')+'$'+closedPnl.toFixed(2);
  tpe.className = 'sv ' + (closedPnl>=0?'g':'r');
  if (best !== null) setText('t-best',  (best>=0?'+':'')+'$'+best.toFixed(2));
  if (worst !== null) setText('t-worst', (worst>=0?'+':'')+'$'+worst.toFixed(2));

  // â”€â”€ Open PnL card (Binance live value preferred) â”€â”€
  const openEl = document.getElementById('open-pnl');
  if (openEl) {
    openEl.textContent = (openPnl>=0?'+':'')+'$'+openPnl.toFixed(2);
    openEl.style.color = openPnl>0?'var(--green)':openPnl<0?'var(--red)':'var(--dim)';
    setText('open-pnl-sub', st.openPos.length+' position'+(st.openPos.length===1?'':'s'));
  }

  // â”€â”€ Closed PnL card â”€â”€
  const closedEl = document.getElementById('closed-pnl');
  if (closedEl) {
    closedEl.textContent = (closedPnl>=0?'+':'')+'$'+closedPnl.toFixed(2);
    closedEl.style.color = closedPnl>0?'var(--green)':closedPnl<0?'var(--red)':'var(--dim)';
    setText('closed-pnl-sub', closed.length+' trade'+(closed.length===1?'':'s')+' (realised)');
  }

  // â”€â”€ Total PnL card (open + closed) â”€â”€
  const totalEl = document.getElementById('total-pnl-card');
  if (totalEl) {
    totalEl.textContent = (totalPnl>=0?'+':'')+'$'+totalPnl.toFixed(2);
    totalEl.style.color = totalPnl>0?'var(--green)':totalPnl<0?'var(--red)':'var(--dim)';
    setText('total-pnl-sub', 'open + closed');
  }

  // Keep st.totalPnl in sync as a cache (for save/load compatibility)
  st.totalPnl = closedPnl;

  drawPnlChart();
}

function renderOpenPos() {
  const el=document.getElementById('openPos');
  if(!st.openPos.length){el.innerHTML='<div class="empty"><div class="ei">ğŸ“­</div>No open positions</div>';return;}
  el.innerHTML=st.openPos.map(t=>{
    const cur=st.prices[t.sym]||t.price;
    const pnl=t.dir==='BUY'?t.notional*(cur-t.price)/t.price:-t.notional*(cur-t.price)/t.price;
    t.pnl=pnl;
    return `<div class="tr" style="cursor:pointer;transition:background .15s" onclick="confirmClose('${t.id}')" onmouseenter="this.style.background='rgba(255,77,109,.04)'" onmouseleave="this.style.background=''">
      <div style="flex:1;min-width:0">
        <div class="tr-sym">${t.sym.replace('USDT','/USDT')}</div>
        <div class="tr-meta" style="margin-top:2px">
          <span class="chip c-open">DEMO</span>
          <span class="chip ${t.dir==='BUY'?'c-long':'c-short'}">${t.dir==='BUY'?'LONG':'SHORT'}</span>
          <span style="color:var(--dim)">$${t.size}Ã—${t.lev}x</span>
        </div>
        <div class="tr-meta" style="margin-top:2px;font-size:10px;color:var(--dim)">TP $${fmt(t.tpPrice)} Â· SL $${fmt(t.slPrice)}</div>
        <div style="margin-top:5px">
          <span style="background:rgba(255,77,109,.15);color:var(--red);font-size:10px;font-weight:700;padding:3px 10px;border-radius:5px;cursor:pointer" onclick="event.stopPropagation();confirmClose('${t.id}')">âœ• CLOSE</span>
        </div>
      </div>
      <div style="text-align:right;flex-shrink:0;padding-left:8px">
        <div class="tr-pnl" style="font-size:16px;font-weight:700;color:${pnl>=0?'var(--green)':'var(--red)'}">${pnl>=0?'+':''}$${pnl.toFixed(2)}</div>
        <div style="font-size:11px;color:var(--dim);margin-top:2px">$${fmt(cur)}</div>
        <div style="font-size:10px;color:var(--dim)">${t.time}</div>
      </div>
    </div>`;
  }).join('');
  setText('posCount',`${st.openPos.length} open`);

  // Refresh open PnL card live
  const livePnl = st.openPos.reduce((sum,t)=>sum+t.pnl,0);
  const el2 = document.getElementById('open-pnl');
  if(el2){
    el2.textContent=(livePnl>=0?'+':'')+'$'+livePnl.toFixed(2);
    el2.style.color=livePnl>0?'var(--green)':livePnl<0?'var(--red)':'var(--dim)';
    setText('open-pnl-sub', st.openPos.length+' position'+(st.openPos.length===1?'':'s'));
  }
}

let tradeFilter = 'all';

function setTradeFilter(f) {
  tradeFilter = f;
  renderTrades();
}

function getTimeFilter() {
  const sel = document.getElementById('tf-time');
  return sel ? sel.value : 'all';
}

function passesTimeFilter(trade) {
  const tf = getTimeFilter();
  if (tf === 'all') return true;
  const now = new Date();
  const tradeTime = trade.openTimestamp || trade._ts || 0;
  if (!tradeTime) return true; // no timestamp â€” show it
  const tradeDt = new Date(tradeTime);
  const todayStart = new Date(now.getFullYear(), now.getMonth(), now.getDate()).getTime();
  const yesterdayStart = todayStart - 86400000;
  if (tf === 'today') return tradeTime >= todayStart;
  if (tf === 'yesterday') return tradeTime >= yesterdayStart && tradeTime < todayStart;
  if (tf === '7d') return tradeTime >= Date.now() - 7*86400000;
  if (tf === '30d') return tradeTime >= Date.now() - 30*86400000;
  return true;
}

let lastSyncTime = 0;
async function refreshTradesFromBinance() {
  const now = Date.now();
  if (now - lastSyncTime < 5000) { toast('Syncingâ€¦ please wait'); return; }
  lastSyncTime = now;
  log('ğŸ”„ Syncing positions from Binanceâ€¦','info');
  await syncPositionsFromBinance();
  renderTrades();
  toast('Synced with Binance âœ“');
}

function mkBox(label, val, col) {
  return '<div style="background:var(--surface);border-radius:6px;padding:6px 8px">' +
    '<div style="font-size:9px;color:var(--dim);text-transform:uppercase;letter-spacing:.5px">' + label + '</div>' +
    '<div style="font-size:12px;font-weight:600;font-family:var(--mono);' + (col?'color:'+col:'') + '">' + val + '</div>' +
    '</div>';
}

function renderTrades() {
  var el = document.getElementById('tradeList');
  if (!el) return;
  el.style.overflowY = 'visible';

  var list = st.allTrades.slice().filter(passesTimeFilter);
  if (tradeFilter === 'open')   list = list.filter(function(t){ return t.status === 'OPEN'; });
  if (tradeFilter === 'closed') list = list.filter(function(t){ return t.status !== 'OPEN'; });
  if (tradeFilter === 'win')    list = list.filter(function(t){ return t.status === 'WIN'; });
  if (tradeFilter === 'loss')   list = list.filter(function(t){ return t.status === 'LOSS'; });
  if (tradeFilter === 'sl')     list = list.filter(function(t){ return t.closeReason === 'Stop Loss'; });
  if (tradeFilter === 'tp')     list = list.filter(function(t){ return t.closeReason === 'Take Profit'; });
  if (tradeFilter === 'manual') list = list.filter(function(t){ return t.closeReason === 'Manual close'; });

  if (!list.length) {
    var msgs = {open:'No open trades',closed:'No closed trades yet',win:'No winning trades',loss:'No losing trades',sl:'No stop loss hits',tp:'No take profit hits',manual:'No manual closes',all:'No trades yet'};
    var msg = msgs[tradeFilter] || 'No trades matching filter';
    el.innerHTML = '<div class="empty"><div class="ei">ğŸ“‹</div>' + msg + '</div>';
    return;
  }

  el.innerHTML = list.map(function(t) {
    var isOpen  = t.status === 'OPEN';
    var cur     = st.prices[t.sym] || t.price;
    var livePnl = isOpen
      ? (t.dir==='BUY' ? t.notional*(cur-t.price)/t.price : -t.notional*(cur-t.price)/t.price)
      : t.pnl;
    if (isOpen) t.pnl = livePnl;

    var pnlPct   = t.notional ? ((livePnl/t.notional)*100).toFixed(2) : '0.00';
    var pnlColor = livePnl >= 0 ? 'var(--green)' : 'var(--red)';
    var pnlStr   = (livePnl>=0?'+':'') + '$' + livePnl.toFixed(2);
    var tradeDir = t.dir === 'BUY' ? 'LONG' : 'SHORT';

    // Current signal on this coin
    var curSig  = isOpen && st.wsReady[t.sym] ? getSignal(t.sym) : null;
    var curDir  = curSig ? curSig.dir : null;
    var curConf = curSig ? curSig.conf : null;
    var agree   = isOpen && curDir ? (curDir === tradeDir) : null;
    var agreeColor = agree===null ? 'var(--dim)' : (agree ? 'var(--green)' : 'var(--red)');
    var agreeLabel = agree===null ? 'â€”' : (agree ? 'âœ… HOLD â€” signal agrees' : 'âš ï¸ CAUTION â€” signal reversed');
    var durMins = (!isOpen && t.openTimestamp && t.closeTimestamp) ? Math.round((t.closeTimestamp-t.openTimestamp)/60000) : 0;
    var duration = durMins>0 ? (durMins>=60 ? Math.floor(durMins/60)+'h '+(durMins%60)+'m' : durMins+'m') : '';

    // Status chip
    var statusChip = isOpen
      ? '<span style="background:rgba(255,193,7,.15);color:var(--yellow);font-size:9px;font-weight:700;padding:2px 6px;border-radius:4px">âš¡ LIVE</span>'
      : '<span style="background:' + (t.status==='WIN'?'rgba(0,230,118,.15)':'rgba(255,77,109,.15)') + ';color:' + (t.status==='WIN'?'var(--green)':'var(--red)') + ';font-size:9px;font-weight:700;padding:2px 6px;border-radius:4px">' + (t.status==='WIN'?'âœ… WIN':'âŒ LOSS') + '</span>';

    // Signal intelligence block
    var sigBlock = isOpen
      ? '<div style="background:rgba(124,111,255,.08);border:1px solid rgba(124,111,255,.2);border-radius:7px;padding:8px 10px;margin-bottom:8px">' +
          '<div style="font-size:9px;text-transform:uppercase;letter-spacing:.5px;color:#7c6fff;margin-bottom:4px">ğŸ“¡ Current Signal Intelligence</div>' +
          '<div style="display:flex;justify-content:space-between;align-items:center">' +
            '<div>' +
              '<div style="font-size:12px;font-weight:700;color:' + (curDir?(curDir==='LONG'?'var(--green)':'var(--red)'):'var(--dim)') + '">' + (curDir ? curDir+' â€” '+curConf+'% conf' : 'No signal now') + '</div>' +
              '<div style="font-size:10px;color:var(--dim);margin-top:2px">Opened as: ' + tradeDir + ' Â· Score: ' + (t.signals||'â€”') + 'âœ“ ' + (t.openConf||'â€”') + '%</div>' +
            '</div>' +
            '<div style="text-align:right"><div style="font-size:11px;font-weight:700;color:' + agreeColor + '">' + agreeLabel + '</div></div>' +
          '</div>' +
        '</div>'
      : '<div style="font-size:10px;color:var(--dim);margin-bottom:6px">ğŸ“Š Opened: ' + (t.openConf||'â€”') + '% conf Â· ' + (t.signals||'â€”') + ' signals Â· ' + (t.openReason||t.reason||'Manual') + '</div>';

    var closeBtn = isOpen
      ? '<span style="background:rgba(255,77,109,.15);color:var(--red);font-size:10px;font-weight:700;padding:4px 12px;border-radius:6px;cursor:pointer" onclick="event.stopPropagation();confirmClose(\''+t.id+'\')">âœ• Close</span>'
      : '';

    return '<div class="card" style="margin-bottom:8px;padding:12px 14px' + (isOpen?';cursor:pointer':'' ) + '"' +
        (isOpen ? ' onclick="confirmClose(\''+t.id+'\')"' : '') + '>' +

      // Header
      '<div style="display:flex;justify-content:space-between;align-items:flex-start;margin-bottom:8px">' +
        '<div>' +
          '<div style="font-size:15px;font-weight:700">' + t.sym.replace('USDT','/USDT') + '</div>' +
          '<div style="display:flex;gap:5px;margin-top:4px;flex-wrap:wrap">' +
            '<span class="chip ' + (t.dir==='BUY'?'c-long':'c-short') + '">' + (t.dir==='BUY'?'â–² LONG':'â–¼ SHORT') + '</span>' +
            statusChip +
          '</div>' +
        '</div>' +
        '<div style="text-align:right">' +
          '<div style="font-size:18px;font-weight:700;color:'+pnlColor+'">' + pnlStr + '</div>' +
          '<div style="font-size:11px;color:'+pnlColor+'">' + (livePnl>=0?'+':'') + pnlPct + '%</div>' +
        '</div>' +
      '</div>' +

      // Details grid
      '<div style="display:grid;grid-template-columns:1fr 1fr 1fr;gap:6px;margin-bottom:8px">' +
        mkBox('Entry', '$'+fmt(t.price)) +
        mkBox('Current', '$'+fmt(cur), isOpen?pnlColor:'var(--dim)') +
        mkBox('Leverage', t.lev+'x', 'var(--accent)') +
        mkBox('Size', '$'+t.size) +
        mkBox('TP', '$'+fmt(t.tpPrice), 'var(--green)') +
        mkBox('SL', '$'+fmt(t.slPrice), 'var(--red)') +
      '</div>' +

      // Signal block
      sigBlock +
      // Footer
      '<div style="display:flex;justify-content:space-between;align-items:center">' +
        '<div style="font-size:10px;color:var(--dim)">' +
          'ğŸ• ' + (t.openTime||t.time) +
          (t.closeTime && !isOpen ? ' â†’ ' + t.closeTime : '') +
          (duration ? ' <span style="color:var(--accent)">(' + duration + ')</span>' : '') +
          (duration ? ' <span style="color:var(--accent)">('+duration+')</span>' : '') +
          (duration ? ' <span style="color:var(--accent)">(' + duration + ')</span>' : '') +
          ' Â· #' + (t.orderId||'manual') +
          (t.closeReason ? ' Â· ' + t.closeReason : '') +
        '</div>' +
        closeBtn +
      '</div>' +
    '</div>';
  }).join('');
}

function updateTicker() {
  const el=document.getElementById('tickerInner');
  const items=SYMBOLS.slice(0,8).map(sym=>{
    const p=st.prices[sym],c=st.change24h[sym]||0;
    if(!p) return '';
    const col=c>=0?'var(--green)':'var(--red)';
    return `<div class="ti"><span class="ti-s">${sym.replace('USDT','')}</span><span class="ti-p">$${fmt(p)}</span><span class="ti-c" style="color:${col}">${c>=0?'+':''}${c.toFixed(2)}%</span></div>`;
  }).filter(Boolean);
  if(!items.length) return;
  el.innerHTML=[...items,...items].join('');
  el.className='ticker-inner go';
}

function drawPnlChart() {
  const canvas=document.getElementById('pnlChart');
  if(!canvas) return;
  const ctx=canvas.getContext('2d');
  const w=canvas.offsetWidth,h=canvas.offsetHeight;
  canvas.width=w*devicePixelRatio; canvas.height=h*devicePixelRatio;
  ctx.scale(devicePixelRatio,devicePixelRatio);
  const data=st.pnlHistory;
  if(data.length<2){ctx.clearRect(0,0,w,h);return;}
  ctx.clearRect(0,0,w,h);
  const min=Math.min(...data),max=Math.max(...data),range=max-min||1;
  const pts=data.map((v,i)=>({x:(i/(data.length-1))*w,y:h-((v-min)/range)*(h-8)-4}));
  const isPos=data[data.length-1]>=0;
  const grad=ctx.createLinearGradient(0,0,0,h);
  grad.addColorStop(0,isPos?'rgba(0,230,118,.3)':'rgba(255,77,109,.3)');
  grad.addColorStop(1,'rgba(0,0,0,0)');
  ctx.beginPath(); ctx.moveTo(pts[0].x,h);
  pts.forEach(p=>ctx.lineTo(p.x,p.y));
  ctx.lineTo(pts[pts.length-1].x,h); ctx.closePath();
  ctx.fillStyle=grad; ctx.fill();
  ctx.beginPath(); pts.forEach((p,i)=>i===0?ctx.moveTo(p.x,p.y):ctx.lineTo(p.x,p.y));
  ctx.strokeStyle=isPos?'#00e676':'#ff4d6d'; ctx.lineWidth=2; ctx.stroke();
  const zy=h-((0-min)/range)*(h-8)-4;
  ctx.beginPath(); ctx.moveTo(0,zy); ctx.lineTo(w,zy);
  ctx.strokeStyle='rgba(255,255,255,.08)'; ctx.lineWidth=1; ctx.setLineDash([4,4]); ctx.stroke(); ctx.setLineDash([]);
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// SHEET / MANUAL
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function buildAnalysisHTML(sym, extra) {
  const p    = st.prices[sym]||0;
  const ch   = st.change24h[sym]||0;
  const cnd  = st.candles[sym]||[];
  const r14  = cnd.length>=15 ? rsi(cnd,14) : 50;
  const r7   = cnd.length>=8  ? rsi(cnd,7)  : 50;
  const cl   = cnd.map(x=>x.close);
  const e9   = cl.length>=9  ? ema(cl,9)  : p;
  const e21  = cl.length>=21 ? ema(cl,21) : p;
  const e50  = cl.length>=50 ? ema(cl.slice(-60),50) : p;
  const m    = cnd.length>=26 ? macd(cnd) : 0;
  const vs   = cnd.length>=11 ? volSpike(cnd) : 1;
  const atrV = cnd.length>=15 ? atr(cnd,14) : 0;
  const atrP = p>0 ? (atrV/p*100) : 0;
  const bb   = cl.length>=20 ? bollingerBands(cl) : {upper:p,lower:p,mid:p};
  const lev  = getDynamicLeverage(sym);
  const sig  = st.wsReady[sym] ? getSignal(sym) : null;

  // Trend direction
  const trend = e9>e21 && e21>e50 ? 'ğŸŸ¢ Strong Uptrend' : e9>e21 ? 'ğŸŸ¡ Weak Uptrend' : e9<e21 && e21<e50 ? 'ğŸ”´ Strong Downtrend' : 'ğŸŸ¡ Weak Downtrend';

  // RSI zone
  const rsiZone = r14<30?'ğŸŸ¢ Oversold â€” bounce likely':r14<45?'ğŸŸ¡ Bullish zone':r14>70?'ğŸ”´ Overbought â€” drop likely':r14>55?'ğŸŸ¡ Bearish zone':'âšª Neutral';

  // BB position
  const bbPos = p>bb.upper?'Above upper band (overbought)':p<bb.lower?'Below lower band (oversold)':p>bb.mid?'Above midline':'Below midline';

  // Signal display
  const sigColor = sig?(sig.dir==='LONG'?'var(--green)':'var(--red)'):'var(--dim)';
  const sigTxt   = sig?sig.dir+' â€” '+sig.conf+'% ('+sig.signals+' confirmations)':'No trade signal';

  return `
    <!-- Price header -->
    <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:14px">
      <div>
        <div style="font-size:22px;font-weight:700;font-family:var(--mono)">$${fmt(p)}</div>
        <div style="font-size:13px;color:${ch>=0?'var(--green)':'var(--red)'};font-weight:600">${ch>=0?'+':''}${ch.toFixed(2)}% (24h)</div>
      </div>
      <div style="text-align:right">
        <div style="font-size:11px;color:var(--dim)">Dynamic Leverage</div>
        <div style="font-size:20px;font-weight:700;color:var(--accent)">${lev}x</div>
        <div style="font-size:10px;color:var(--dim)">ATR ${atrP.toFixed(2)}%</div>
      </div>
    </div>

    <!-- Signal verdict -->
    <div style="background:${sig?(sig.dir==='LONG'?'rgba(0,230,118,.08)':'rgba(255,77,109,.08)'):'rgba(85,85,112,.08)'};border:1px solid ${sig?(sig.dir==='LONG'?'rgba(0,230,118,.3)':'rgba(255,77,109,.3)'):'var(--border)'};border-radius:10px;padding:12px;margin-bottom:12px">
      <div style="font-size:10px;letter-spacing:1px;text-transform:uppercase;color:var(--dim);margin-bottom:4px">Signal Verdict</div>
      <div style="font-size:16px;font-weight:700;color:${sigColor}">${sigTxt}</div>
      <div style="font-size:11px;color:var(--dim);margin-top:4px;line-height:1.6">${sig?sig.reason:(cnd.length<50?'Need '+Math.max(0,50-cnd.length)+' more candles':'No confluence found')}</div>
    </div>

    <!-- Indicators grid -->
    <div style="display:grid;grid-template-columns:1fr 1fr;gap:8px;margin-bottom:12px">
      <div style="background:var(--surface);border:1px solid var(--border);border-radius:8px;padding:10px">
        <div style="font-size:9px;text-transform:uppercase;color:var(--dim);letter-spacing:1px">RSI 14</div>
        <div style="font-size:18px;font-weight:700;color:${r14<35||r14>65?'var(--accent)':'var(--text)'};font-family:var(--mono)">${r14.toFixed(1)}</div>
        <div style="font-size:10px;color:var(--dim)">${rsiZone}</div>
      </div>
      <div style="background:var(--surface);border:1px solid var(--border);border-radius:8px;padding:10px">
        <div style="font-size:9px;text-transform:uppercase;color:var(--dim);letter-spacing:1px">RSI 7</div>
        <div style="font-size:18px;font-weight:700;color:${r7<35||r7>65?'var(--accent)':'var(--text)'};font-family:var(--mono)">${r7.toFixed(1)}</div>
        <div style="font-size:10px;color:var(--dim)">${r7>r14?'Rising fast':'Falling fast'}</div>
      </div>
      <div style="background:var(--surface);border:1px solid var(--border);border-radius:8px;padding:10px">
        <div style="font-size:9px;text-transform:uppercase;color:var(--dim);letter-spacing:1px">MACD</div>
        <div style="font-size:18px;font-weight:700;color:${m>0?'var(--green)':'var(--red)'};font-family:var(--mono)">${m>0?'+':''}${m.toFixed(4)}</div>
        <div style="font-size:10px;color:var(--dim)">${m>0?'Bullish momentum':'Bearish momentum'}</div>
      </div>
      <div style="background:var(--surface);border:1px solid var(--border);border-radius:8px;padding:10px">
        <div style="font-size:9px;text-transform:uppercase;color:var(--dim);letter-spacing:1px">Volume</div>
        <div style="font-size:18px;font-weight:700;color:${vs>2?'var(--accent)':vs>1.3?'var(--yellow)':'var(--text)'};font-family:var(--mono)">${vs.toFixed(2)}x</div>
        <div style="font-size:10px;color:var(--dim)">${vs>2?'High volume!':vs>1.3?'Above average':'Normal'}</div>
      </div>
    </div>

    <!-- EMA levels -->
    <div style="background:var(--surface);border:1px solid var(--border);border-radius:8px;padding:10px;margin-bottom:12px">
      <div style="font-size:9px;text-transform:uppercase;color:var(--dim);letter-spacing:1px;margin-bottom:8px">EMA Levels & Trend</div>
      <div style="font-size:12px;color:var(--dim)">${trend}</div>
      <div style="display:flex;justify-content:space-between;margin-top:8px">
        <span style="font-size:11px">EMA9: <strong style="color:${p>e9?'var(--green)':'var(--red)'}">$${fmt(e9)}</strong></span>
        <span style="font-size:11px">EMA21: <strong style="color:${p>e21?'var(--green)':'var(--red)'}">$${fmt(e21)}</strong></span>
        <span style="font-size:11px">EMA50: <strong style="color:${p>e50?'var(--green)':'var(--red)'}">$${fmt(e50)}</strong></span>
      </div>
    </div>

    <!-- Bollinger Bands -->
    <div style="background:var(--surface);border:1px solid var(--border);border-radius:8px;padding:10px;margin-bottom:14px">
      <div style="font-size:9px;text-transform:uppercase;color:var(--dim);letter-spacing:1px;margin-bottom:6px">Bollinger Bands</div>
      <div style="font-size:11px;margin-bottom:4px">Upper: <strong>$${fmt(bb.upper)}</strong> Â· Mid: <strong>$${fmt(bb.mid)}</strong> Â· Lower: <strong>$${fmt(bb.lower)}</strong></div>
      <div style="font-size:11px;color:var(--dim)">${bbPos}</div>
    </div>

    <!-- Trade buttons with size input -->
    <div style="margin-bottom:8px">
      <div style="font-size:10px;text-transform:uppercase;color:var(--dim);letter-spacing:1px;margin-bottom:6px">Trade Size ($) Â· Leverage: ${lev}x auto</div>
      <input class="fi" id="tradeSize" type="number" value="${st.cfg.size}" style="margin-bottom:8px;text-align:center;font-size:16px;font-weight:700">
    </div>
    <div class="b2" style="gap:8px">
      <button class="btn btn-g" style="font-size:15px;padding:14px" onclick="analyzeAndTrade('${sym}','BUY')">â–² LONG ${sym.replace('USDT','')}</button>
      <button class="btn btn-r" style="font-size:15px;padding:14px" onclick="analyzeAndTrade('${sym}','SELL')">â–¼ SHORT ${sym.replace('USDT','')}</button>
    </div>
    ${extra||''}`;
}

async function searchAndAnalyze() {
  let input = document.getElementById('searchInput').value.trim().toUpperCase();
  if (!input) { toast('Enter a coin name'); return; }

  // Auto-append USDT if not present
  if (!input.endsWith('USDT')) input = input + 'USDT';

  const resultDiv = document.getElementById('searchResult');
  resultDiv.style.display = 'block';
  resultDiv.innerHTML = '<div style="text-align:center;padding:20px;color:var(--dim)">â³ Loading '+input+'â€¦</div>';

  // Fetch candles if we don't have them
  if (!st.candles[input] || st.candles[input].length < 20) {
    try {
      // Try futures klines first, fallback to spot
      let raw = null;
      try {
        const rf = await fetch('https://fapi.binance.com/fapi/v1/klines?symbol='+input+'&interval=5m&limit=500');
        const rfd = await rf.json();
        if (Array.isArray(rfd) && rfd.length > 10) raw = rfd;
      } catch(_) {}
      if (!raw) {
        const rs = await fetch('https://api.binance.com/api/v3/klines?symbol='+input+'&interval=5m&limit=500');
        const rsd = await rs.json();
        if (Array.isArray(rsd) && rsd.length > 10) raw = rsd;
      }
      if (!raw || raw.length === 0) {
        resultDiv.innerHTML = '<div style="padding:14px;color:var(--red)">âŒ "'+input+'" not found on Binance Futures or Spot.<br><small style=\'color:var(--dim)\'>Some very new tokens may not be available. Try adding USDT manually e.g. PIPPINUSDT</small></div>';
        return;
      }
      st.candles[input] = raw.map(k=>({open:+k[1],high:+k[2],low:+k[3],close:+k[4],vol:+k[5],closed:true}));
      st.wsReady[input] = true;
      // Also get live price via ticker
      // Try futures price first, fallback to spot
      try {
        const tf = await fetch('https://fapi.binance.com/fapi/v1/ticker/24hr?symbol='+input);
        const tfd = await tf.json();
        if(tfd.lastPrice){ st.prices[input]=parseFloat(tfd.lastPrice); st.change24h[input]=parseFloat(tfd.priceChangePercent); }
      } catch(_) {
        const tr = await fetch('https://api.binance.com/api/v3/ticker/24hr?symbol='+input);
        const td = await tr.json();
        if(td.lastPrice){ st.prices[input]=parseFloat(td.lastPrice); st.change24h[input]=parseFloat(td.priceChangePercent); }
      }
      // Add to SYMBOLS if not present
      if (!SYMBOLS.includes(input)) SYMBOLS.push(input);
    } catch(e) {
      resultDiv.innerHTML = '<div style="padding:14px;color:var(--red)">âŒ Error loading '+input+': '+e.message+'</div>';
      return;
    }
  }

  resultDiv.innerHTML = buildAnalysisHTML(input, '');
  log('ğŸ” Analyzed: '+input,'ok');
}

async function analyzeAndTrade(sym, dir) {
  const sizeEl = document.getElementById('tradeSize');
  const size = sizeEl ? parseFloat(sizeEl.value)||st.cfg.size : st.cfg.size;
  closeSheet();
  // Hide search result panel after trade
  const rd = document.getElementById('searchResult');
  if (rd) rd.style.display='none';
  await placeOrder(sym, dir, size);
}

function openSheet(sym) {
  document.getElementById('sh-title').textContent = sym.replace('USDT','/USDT');
  document.getElementById('sh-body').innerHTML = buildAnalysisHTML(sym, '');
  document.getElementById('sheet').classList.add('show');
}
function closeSheet(){ document.getElementById('sheet').classList.remove('show'); }
async function sheetOrder(sym,dir){ closeSheet(); await placeOrder(sym,dir,st.cfg.size); }

async function manualOrder(dir) {
  let sym = (document.getElementById('manSym').value||'').trim().toUpperCase();
  if (!sym) { toast('Enter a symbol first'); return; }
  if (!sym.endsWith('USDT')) sym = sym + 'USDT';
  const size = parseFloat(document.getElementById('manSize').value)||st.cfg.size;
  const manLevVal = parseInt(document.getElementById('manLev').value)||0;
  // Load candles if needed for auto leverage
  if (!st.candles[sym] || st.candles[sym].length < 20) {
    log('â³ Loading '+sym+' data for tradeâ€¦','info');
    try {
      const r = await fetch('https://api.binance.com/api/v3/klines?symbol='+sym+'&interval=5m&limit=200');
      const raw = await r.json();
      if (Array.isArray(raw) && raw.length>0) {
        st.candles[sym]=raw.map(k=>({open:+k[1],high:+k[2],low:+k[3],close:+k[4],vol:+k[5],closed:true}));
        st.wsReady[sym]=true;
        const tr=await fetch('https://api.binance.com/api/v3/ticker/price?symbol='+sym);
        const td=await tr.json();
        if(td.price) st.prices[sym]=parseFloat(td.price);
      }
    } catch(e){ log('Could not load '+sym+': '+e.message,'err'); }
  }
  const lev = manLevVal > 0 ? manLevVal : getDynamicLeverage(sym);
  st.cfg.leverage = lev;
  await placeOrder(sym, dir==='BUY'?'BUY':'SELL', size);
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// UTILS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function setBanner(type, msg) {
  const b=document.getElementById('connBanner'), d=document.getElementById('connDot'), t=document.getElementById('connText');
  b.className=`banner bn-${type}`; t.textContent=msg;
  d.className=`bn-dot ${type==='ok'?'pulse':''}`;
}
function saveConfig(){
  st.cfg.strategy=document.getElementById('cfgStrat').value;
  st.cfg.size=parseFloat(document.getElementById('cfgSize').value)||45;
  st.cfg.leverage=parseInt(document.getElementById('cfgLev').value)||5;
  st.cfg.tp=parseFloat(document.getElementById('cfgTP').value)||10;
  st.cfg.sl=parseFloat(document.getElementById('cfgSL').value)||8;
  st.cfg.maxTrades=parseInt(document.getElementById('cfgMaxT').value)||20;
  st.cfg.maxOpen=parseInt(document.getElementById('cfgMaxP').value)||3;
  toast('Config saved âœ“');
  if(st.connected) updateAPIStatus();
}
function togSet(k){ st.togs[k]=!st.togs[k]; document.getElementById('tog-'+k).classList.toggle('on',st.togs[k]); }
function toggleEye(id, btn){ const i=document.getElementById(id); i.type=i.type==='password'?'text':'password'; btn.textContent=i.type==='password'?'ğŸ‘':'ğŸ™ˆ'; }

function log(msg, type='info') {
  const el=document.getElementById('logBox');
  if (!el) return;
  const t=new Date().toLocaleTimeString('en',{hour12:false});
  const d=document.createElement('div'); d.className=`ll ${type}`;
  d.innerHTML=`<span class="lt">${t}</span>${msg}`;
  el.appendChild(d); el.scrollTop=el.scrollHeight;
  if(el.children.length>400) el.removeChild(el.firstChild);
}

function clearHistory(){
  st.allTrades=st.allTrades.filter(t=>t.status==='OPEN');
  st.wins=0;st.losses=0;st.totalPnl=0;st.todayPnl=0;st.todayLoss=0;
  st.liveOpenPnl=null;st.pnlHistory=[0];
  renderTrades();updateDash();toast('Closed trades cleared');
}

function resetEverything() {
  if (!confirm('âš ï¸ FULL RESET\n\nThis will:\nâ€¢ Clear ALL trades (open + closed)\nâ€¢ Reset all stats to zero\nâ€¢ Clear localStorage\n\nMake sure Binance is also reset first.\n\nContinue?')) return;
  // Stop bot if running
  if (st.running) stopBot();
  // Clear all state
  st.openPos      = [];
  st.allTrades    = [];
  st.wins         = 0;
  st.losses       = 0;
  st.totalPnl     = 0;
  st.todayPnl     = 0;
  st.todayLoss    = 0;
  st.tradeCount   = 0;
  st.pnlHistory   = [0];
  st.liveOpenPnl  = null;
  st.liveBalance  = null;
  st.capital      = 2000;
  st.tickStep     = 0;
  if (st.pendingOrder) st.pendingOrder.clear();
  closingGuard.clear();
  // Wipe localStorage completely
  localStorage.removeItem('demoTrades');
  localStorage.removeItem('demoOpenPos');
  localStorage.removeItem('demoStats');
  localStorage.removeItem('blockedSyms');
  // Re-render everything
  renderOpenPos();
  renderTrades();
  updateDash();
  drawPnlChart();
  log('ğŸ”„ Full reset complete â€” starting fresh!', 'ok');
  toast('âœ… Bot reset â€” fresh start!');
}
function setText(id,v){ const e=document.getElementById(id);if(e)e.textContent=v; }
function shuffle(a){ return [...a].sort(()=>Math.random()-.5); }
function fmt(n){ if(!n&&n!==0)return'â€”';if(n>=10000)return n.toFixed(1);if(n>=100)return n.toFixed(2);if(n>=1)return n.toFixed(3);if(n>=0.1)return n.toFixed(4);return n.toFixed(6); }
function toast(msg){ const el=document.createElement('div');el.className='toast';el.textContent=msg;document.body.appendChild(el);setTimeout(()=>el.style.opacity='0',1800);setTimeout(()=>el.remove(),2100); }

function copyLog() {
  const el = document.getElementById('logBox');
  if (!el) return;
  const text = Array.from(el.children).map(c=>c.textContent).join('\n');
  navigator.clipboard.writeText(text).then(()=>toast('Log copied! âœ“')).catch(()=>{
    // Fallback for mobile
    const ta=document.createElement('textarea');
    ta.value=text; document.body.appendChild(ta);
    ta.select(); document.execCommand('copy');
    ta.remove(); toast('Log copied! âœ“');
  });
}

async function forceScan() {
  if (!st.connected){ toast('Connect API keys first'); nav('keys'); return; }
  log('â–¶ Manual scan triggeredâ€¦','info');
  await botLoop();
}

function nav(page) {
  document.querySelectorAll('.page').forEach(p=>p.classList.remove('active'));
  document.querySelectorAll('.tab').forEach(t=>t.classList.remove('active'));
  document.getElementById('pg-'+page).classList.add('active');
  ['dash','scanner','trades','config','setup'].forEach((p,i)=>{
    if(p===page) document.querySelectorAll('.tab')[i].classList.add('active');
  });
  if(page==='trades') renderTrades();
  if(page==='scanner') { runScan(); }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// INIT
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
window.addEventListener('load', () => {
  // Restore previous trades & open positions first
  loadState();
  // Pre-populate scan with base symbols immediately so tab isn't blank
  setTimeout(() => runScan(), 100);

  // Restore session keys if available
  const k=localStorage.getItem('demoKey'), s=localStorage.getItem('demoSecret'), px=localStorage.getItem('demoProxy');
  if(px) activeProxy=px;
  if(k && s) {
    document.getElementById('apiKey').value    = k;
    document.getElementById('apiSecret').value = s;
    log('ğŸ”‘ Saved keys found â€” auto-reconnectingâ€¦','warn');
    setTimeout(()=>{ document.getElementById('connectBtn').click(); }, 1500);
  }

  updateDash(); renderOpenPos(); renderTrades(); drawPnlChart();
  document.getElementById('sheet').addEventListener('click',e=>{ if(e.target===document.getElementById('sheet')) closeSheet(); });
  window.addEventListener('resize', drawPnlChart);
  setInterval(()=>{ renderOpenPos(); updateDash(); }, 5000);

  log('â—ˆ Binance Demo Bot ready.','ok');
  log('ğŸ‘‰ Go to the Keys tab â†’ paste your demo-fapi API keys â†’ tap Connect','info');
});
</script>
</body>
</html>
